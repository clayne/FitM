diff --git a/qemu/include/afl-fuzz.h b/qemu/include/afl-fuzz.h
index 2203cfdf..de2884ec 100644
--- a/qemu/include/afl-fuzz.h
+++ b/qemu/include/afl-fuzz.h
@@ -612,6 +612,9 @@ typedef struct afl_state {
    * they do not call another function */
   u8 *map_tmp_buf;
 
+  char *restore_path;
+  u8    use_restored_qemu;
+
 } afl_state_t;
 
 struct custom_mutator {
diff --git a/qemu/include/common.h b/qemu/include/common.h
index 4aed9572..489847f6 100644
--- a/qemu/include/common.h
+++ b/qemu/include/common.h
@@ -44,7 +44,7 @@ void check_environment_vars(char **env);
 char **argv_cpy_dup(int argc, char **argv);
 void   argv_cpy_free(char **argv);
 
-char **get_qemu_argv(u8 *own_loc, u8 **target_path_p, int argc, char **argv);
+char **get_qemu_argv(u8 *own_loc, u8 **target_path_p, int argc, char **argv, u8 *restore_path);
 char **get_wine_argv(u8 *own_loc, u8 **target_path_p, int argc, char **argv);
 char * get_afl_env(char *env);
 
diff --git a/qemu/patches/afl-qemu-common.h b/qemu/patches/afl-qemu-common.h
index 94f853cc..ec467873 100644
--- a/qemu/patches/afl-qemu-common.h
+++ b/qemu/patches/afl-qemu-common.h
@@ -88,7 +88,7 @@ extern __thread abi_ulong afl_prev_loc;
 extern struct cmp_map *__afl_cmp_map;
 extern __thread u32    __afl_cmp_counter;
 
-void afl_setup(void);
+void afl_setup(char *, char *);
 void afl_forkserver(CPUState *cpu);
 
 // void afl_debug_dump_saved_regs(void);
diff --git a/qemu/patches/afl-qemu-cpu-inl.h b/qemu/patches/afl-qemu-cpu-inl.h
index 06243141..b70efe1d 100644
--- a/qemu/patches/afl-qemu-cpu-inl.h
+++ b/qemu/patches/afl-qemu-cpu-inl.h
@@ -123,22 +123,19 @@ struct afl_chain {
 
 /* Some forward decls: */
 
-TranslationBlock *tb_htable_lookup(CPUState *, target_ulong, target_ulong,
-                                   uint32_t, uint32_t);
 static inline TranslationBlock *tb_find(CPUState *, TranslationBlock *, int,
                                         uint32_t);
 static inline void              tb_add_jump(TranslationBlock *tb, int n,
                                             TranslationBlock *tb_next);
 
+
 /*************************
  * ACTUAL IMPLEMENTATION *
  *************************/
 
 /* Set up SHM region and initialize other stuff. */
 
-void afl_setup(void) {
-
-  char *id_str = getenv(SHM_ENV_VAR), *inst_r = getenv("AFL_INST_RATIO");
+void afl_setup(char *id_str, char *inst_r) {
 
   int shm_id;
 
@@ -157,15 +154,18 @@ void afl_setup(void) {
 
   if (id_str) {
 
-    shm_id = atoi(id_str);
-    afl_area_ptr = shmat(shm_id, NULL, 0);
+      shm_id = atoi(id_str);
+      afl_area_ptr = shmat(shm_id, NULL, 0);
 
-    if (afl_area_ptr == (void *)-1) exit(1);
+      if (afl_area_ptr == (void *)-1) {
+        perror("SHMAT didn't work");
+        exit(1);
+      };
 
-    /* With AFL_INST_RATIO set to a low value, we want to touch the bitmap
-       so that the parent doesn't give up on us. */
+      /* With AFL_INST_RATIO set to a low value, we want to touch the bitmap
+         so that the parent doesn't give up on us. */
 
-    if (inst_r) afl_area_ptr[0] = 1;
+      if (inst_r) afl_area_ptr[0] = 1;
 
   }
 
@@ -277,7 +277,7 @@ void afl_setup(void) {
 
 static void print_mappings(void) {
 
-  u8    buf[MAX_LINE];
+  char buf[MAX_LINE];
   FILE *f = fopen("/proc/self/maps", "r");
 
   if (!f) return;
diff --git a/qemu/qemu/accel/tcg/translator.c b/qemu/qemu/accel/tcg/translator.c
index 773ea712..0df50864 100644
--- a/qemu/qemu/accel/tcg/translator.c
+++ b/qemu/qemu/accel/tcg/translator.c
@@ -96,8 +96,8 @@ void translator_loop(const TranslatorOps *ops, DisasContextBase *db,
         }
         
         if (db->pc_next == afl_entry_point) {
-          afl_setup();
-          gen_helper_afl_entry_routine(cpu_env);
+        //   afl_setup();
+        //   gen_helper_afl_entry_routine(cpu_env);
         }
 
         /* Disassemble one instruction.  The translate_insn hook should
diff --git a/qemu/qemu/build-for-afl.sh b/qemu/qemu/build-for-afl.sh
index 3689b890..5bd8ac27 100755
--- a/qemu/qemu/build-for-afl.sh
+++ b/qemu/qemu/build-for-afl.sh
@@ -1,3 +1,8 @@
+#!/bin/bash
+
+export LIBS='-lprotobuf-c -luuid'
+export LDFLAGS="$LIBS"
+export QEMU_LDFLAGS="$LIBS"
 ./configure --disable-system --enable-linux-user --disable-gtk --disable-sdl --disable-vnc \
             --enable-capstone=internal --target-list="x86_64-linux-user" --disable-bsd-user \
             --disable-guest-agent --disable-strip --disable-werror --disable-gcrypt \
@@ -10,6 +15,8 @@
             --disable-snappy --disable-spice --disable-libssh2 --disable-libusb --disable-usb-redir \
             --disable-vde --disable-vhost-net --disable-virglrenderer --disable-virtfs --disable-vnc \
             --disable-vte --disable-xen --disable-xen-pci-passthrough --disable-xfsctl \
-            --disable-system --disable-blobs --disable-tools
+            --disable-system --disable-blobs --disable-tools --python=`which python3` \
+	    --extra-ldflags="$LIBS"
 
-make
\ No newline at end of file
+make -j$(nproc) CLFAGS="$LIBS"
+cp ./x86_64-linux-user/qemu-x86_64 ../../fitm-qemu-trace
diff --git a/qemu/qemu/linux-user/criu.h b/qemu/qemu/linux-user/criu.h
new file mode 100644
index 00000000..521699ea
--- /dev/null
+++ b/qemu/qemu/linux-user/criu.h
@@ -0,0 +1,185 @@
+//
+// Created by hirnheiner on 11.05.20.
+// Checkout the Makefile
+
+#include "rpc.pb-c.h"
+#include <stdlib.h>
+#include <stdbool.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <uuid/uuid.h>
+
+#include "fitm.h"
+
+#define MAX_MSG_SIZE 1024
+
+char* get_new_uuid(void);
+int do_criu(void);
+char* concat3(char *first, char *second, char *third);
+
+
+static int send_req(int socket_fd, CriuReq *req)
+{
+    unsigned char buf[MAX_MSG_SIZE];
+    int len;
+
+    len = criu_req__get_packed_size(req);
+
+    if (criu_req__pack(req, buf) != len) {
+        perror("Failed packing request");
+        return -1;
+    }
+
+    if (write(socket_fd, buf, len)  == -1) {
+        perror("Can't send request");
+        return -1;
+    }
+
+    return 0;
+}
+
+static CriuResp *recv_resp(int socket_fd)
+{
+	unsigned char buf[MAX_MSG_SIZE];
+	int len;
+	CriuResp *msg = 0;
+
+	len = read(socket_fd, buf, MAX_MSG_SIZE);
+	if (len == -1) {
+		perror("Can't read response");
+		return NULL;
+	}
+
+	msg = criu_resp__unpack(NULL, len, buf);
+	if (!msg) {
+		perror("Failed unpacking response");
+		return NULL;
+	}
+
+	return msg;
+}
+
+int do_criu(void){
+    int ret = 0;
+    CriuReq req	        = CRIU_REQ__INIT;
+    CriuResp *resp      = NULL;
+    int fd, dir_fd;
+    struct sockaddr_un addr;
+    socklen_t addr_len;
+
+    char *uuid = get_new_uuid();
+    char path[44] = "/tmp/";
+    strncat(path, uuid, 37);
+    close(open(path, O_RDWR | O_CREAT, 0644));
+
+    char *snapshot_dir = getenv_from_file("CRIU_SNAPSHOT_DIR");
+
+    dir_fd = open(snapshot_dir, O_DIRECTORY);
+    if (dir_fd == -1) {
+        perror("Can't open snapshot dir");
+        return -1;
+    }
+
+    req.type			= CRIU_REQ_TYPE__DUMP;
+    req.opts			= malloc(sizeof(CriuOpts));
+    if (!req.opts) {
+        perror("Can't allocate memory for dump request");
+        return -1;
+    }
+
+    criu_opts__init(req.opts);
+    req.opts->images_dir_fd		= dir_fd;
+    req.opts->log_level		= 4;
+    req.opts->leave_running = true;
+
+    fd = socket(AF_LOCAL, SOCK_SEQPACKET, 0);
+    if (fd == -1) {
+        perror("Can't create socket");
+        return -1;
+    }
+
+    memset(&addr, 0, sizeof(addr));
+    addr.sun_family = AF_LOCAL;
+
+    strcpy(addr.sun_path, "/tmp/criu_service.socket");
+
+    addr_len = strlen(addr.sun_path) + sizeof(addr.sun_family);
+
+    ret = connect(fd, (struct sockaddr *) &addr, addr_len);
+    if (ret == -1) {
+        perror("Otto, mach mal CRIU an!");
+        goto exit;
+    }
+
+    /*
+    * Send request
+    */
+    ret = send_req(fd, &req);
+    if (ret == -1) {
+        perror("Can't send request");
+        goto exit;
+    }
+
+    /*
+    * Recv response
+    */
+    resp = recv_resp(fd);
+    if (!resp) {
+        perror("Can't recv response");
+        ret = -1;
+        goto exit;
+    }
+
+    if (resp->type != CRIU_REQ_TYPE__DUMP) {
+        perror("Unexpected response type");
+        ret = -1;
+        goto exit;
+    }
+
+    /*
+    * Check response.
+    */
+    if (resp->success){
+        puts("Success");
+    }
+    else {
+        puts("Fail");
+        ret = -1;
+        goto exit;
+    }
+
+    if (resp->dump->has_restored && resp->dump->restored)
+        puts("Restored");
+
+
+    // Closing the socket FD before the process is dumped breaks CRIU
+exit:
+    close(fd);
+    close(dir_fd);
+    if (resp)
+        criu_resp__free_unpacked(resp, NULL);
+
+    return ret;
+}
+
+char* get_new_uuid(void){
+    // Taken from: https://stackoverflow.com/questions/51053568/generating-a-random-uuid-in-c
+    uuid_t binuuid;
+    uuid_generate_random(binuuid);
+
+    char *uuid = malloc(37);
+    uuid_unparse_lower(binuuid, uuid);
+    return uuid;
+}
+
+char* concat3(char *first, char *second, char *third){
+    char *ret = (char *)calloc(strlen(first)+strlen(second)+strlen(third)+4, 1);
+    strncpy(ret, first, strlen(first)+1);
+    strncat(ret, second, strlen(second)+1);
+    strncat(ret, third, strlen(third)+1);
+    return ret;
+}
diff --git a/qemu/qemu/linux-user/fitm.h b/qemu/qemu/linux-user/fitm.h
new file mode 100644
index 00000000..6c71219d
--- /dev/null
+++ b/qemu/qemu/linux-user/fitm.h
@@ -0,0 +1,73 @@
+#include <fcntl.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+// ignore return value
+int _ = 0;
+
+char *getenv_from_file(const char *var);
+
+/*
+ * Checks if an `envfile` is present. If not checks getenv for the variable.
+ * Note: env is not checked if the file is present.
+ * Also need to handle NULL as return value in the caller
+*/
+char *getenv_from_file(const char *var) {
+    char *found = NULL;
+
+    // https://stackoverflow.com/questions/14002954/c-programming-how-to-read-the-whole-file-contents-into-a-buffer
+    // Read the entire env file
+    // pwd is set to the current state folder.
+    FILE *f = fopen("envfile", "r");
+    if (!f) {
+        return getenv(var);
+    }
+
+    fseek(f, 0, SEEK_END);
+    long fsize = ftell(f);
+    fseek(f, 0, SEEK_SET);  /* same as rewind(f); */
+
+    char *string = calloc(fsize + 1, 1);
+    if (!string) {
+        perror("Failed to calloc in fitm.h:getenv_from_file");
+        exit(-2);
+    }
+    _ = fread(string, 1, fsize, f);
+    fclose(f);
+
+    char *tmp = string;
+
+    while (!found && tmp) {
+        if (!strncmp(var, tmp, strlen(var))) {
+            found = tmp;
+        }
+        tmp = strchr(tmp, '\n');
+        if (tmp) {
+            *tmp = '\0';
+            tmp++;
+        }
+    }
+
+    if (!found) {
+        free(string);
+        return NULL;
+    }
+
+    found = strchr(found, '=');
+    if (!found) {
+        free(string);
+        return NULL;
+    }
+    found++;
+    char *ret = (char *)calloc(strlen(found), 1);
+    if (!ret) {
+        perror("Failed to calloc in fitm.h:getenv_from_file");
+        exit(-1);
+    }
+    strncpy(ret, found, strlen(found));
+    ret[strlen(ret)] = '\0';
+    free(string);
+
+    return ret;
+}
\ No newline at end of file
diff --git a/qemu/qemu/linux-user/rpc.pb-c.h b/qemu/qemu/linux-user/rpc.pb-c.h
new file mode 100644
index 00000000..45070467
--- /dev/null
+++ b/qemu/qemu/linux-user/rpc.pb-c.h
@@ -0,0 +1,3322 @@
+/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
+/* Generated from: rpc.proto */
+
+#ifndef PROTOBUF_C_rpc_2eproto__INCLUDED
+#define PROTOBUF_C_rpc_2eproto__INCLUDED
+
+#include <protobuf-c/protobuf-c.h>
+
+PROTOBUF_C__BEGIN_DECLS
+
+#if PROTOBUF_C_VERSION_NUMBER < 1000000
+# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
+#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
+# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
+#endif
+
+
+typedef struct _CriuPageServerInfo CriuPageServerInfo;
+typedef struct _CriuVethPair CriuVethPair;
+typedef struct _ExtMountMap ExtMountMap;
+typedef struct _JoinNamespace JoinNamespace;
+typedef struct _InheritFd InheritFd;
+typedef struct _CgroupRoot CgroupRoot;
+typedef struct _UnixSk UnixSk;
+typedef struct _CriuOpts CriuOpts;
+typedef struct _CriuDumpResp CriuDumpResp;
+typedef struct _CriuRestoreResp CriuRestoreResp;
+typedef struct _CriuNotify CriuNotify;
+typedef struct _CriuFeatures CriuFeatures;
+typedef struct _CriuReq CriuReq;
+typedef struct _CriuResp CriuResp;
+typedef struct _CriuVersion CriuVersion;
+
+
+/* --- enums --- */
+
+typedef enum _CriuCgMode {
+  CRIU_CG_MODE__IGNORE = 0,
+  CRIU_CG_MODE__CG_NONE = 1,
+  CRIU_CG_MODE__PROPS = 2,
+  CRIU_CG_MODE__SOFT = 3,
+  CRIU_CG_MODE__FULL = 4,
+  CRIU_CG_MODE__STRICT = 5,
+  CRIU_CG_MODE__DEFAULT = 6
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CRIU_CG_MODE)
+} CriuCgMode;
+typedef enum _CriuPreDumpMode {
+  CRIU_PRE_DUMP_MODE__SPLICE = 1,
+  CRIU_PRE_DUMP_MODE__VM_READ = 2
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CRIU_PRE_DUMP_MODE)
+} CriuPreDumpMode;
+typedef enum _CriuReqType {
+  CRIU_REQ_TYPE__EMPTY = 0,
+  CRIU_REQ_TYPE__DUMP = 1,
+  CRIU_REQ_TYPE__RESTORE = 2,
+  CRIU_REQ_TYPE__CHECK = 3,
+  CRIU_REQ_TYPE__PRE_DUMP = 4,
+  CRIU_REQ_TYPE__PAGE_SERVER = 5,
+  CRIU_REQ_TYPE__NOTIFY = 6,
+  CRIU_REQ_TYPE__CPUINFO_DUMP = 7,
+  CRIU_REQ_TYPE__CPUINFO_CHECK = 8,
+  CRIU_REQ_TYPE__FEATURE_CHECK = 9,
+  CRIU_REQ_TYPE__VERSION = 10,
+  CRIU_REQ_TYPE__WAIT_PID = 11,
+  CRIU_REQ_TYPE__PAGE_SERVER_CHLD = 12
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CRIU_REQ_TYPE)
+} CriuReqType;
+
+/* --- messages --- */
+
+struct  _CriuPageServerInfo
+{
+  ProtobufCMessage base;
+  char *address;
+  protobuf_c_boolean has_port;
+  int32_t port;
+  protobuf_c_boolean has_pid;
+  int32_t pid;
+  protobuf_c_boolean has_fd;
+  int32_t fd;
+};
+#define CRIU_PAGE_SERVER_INFO__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_page_server_info__descriptor) \
+    , NULL, 0, 0, 0, 0, 0, 0 }
+
+
+struct  _CriuVethPair
+{
+  ProtobufCMessage base;
+  char *if_in;
+  char *if_out;
+};
+#define CRIU_VETH_PAIR__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_veth_pair__descriptor) \
+    , NULL, NULL }
+
+
+struct  _ExtMountMap
+{
+  ProtobufCMessage base;
+  char *key;
+  char *val;
+};
+#define EXT_MOUNT_MAP__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&ext_mount_map__descriptor) \
+    , NULL, NULL }
+
+
+struct  _JoinNamespace
+{
+  ProtobufCMessage base;
+  char *ns;
+  char *ns_file;
+  char *extra_opt;
+};
+#define JOIN_NAMESPACE__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&join_namespace__descriptor) \
+    , NULL, NULL, NULL }
+
+
+struct  _InheritFd
+{
+  ProtobufCMessage base;
+  char *key;
+  int32_t fd;
+};
+#define INHERIT_FD__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&inherit_fd__descriptor) \
+    , NULL, 0 }
+
+
+struct  _CgroupRoot
+{
+  ProtobufCMessage base;
+  char *ctrl;
+  char *path;
+};
+#define CGROUP_ROOT__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&cgroup_root__descriptor) \
+    , NULL, NULL }
+
+
+struct  _UnixSk
+{
+  ProtobufCMessage base;
+  uint32_t inode;
+};
+#define UNIX_SK__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&unix_sk__descriptor) \
+    , 0 }
+
+
+struct  _CriuOpts
+{
+  ProtobufCMessage base;
+  int32_t images_dir_fd;
+  /*
+   * if not set on dump, will dump requesting process
+   */
+  protobuf_c_boolean has_pid;
+  int32_t pid;
+  protobuf_c_boolean has_leave_running;
+  protobuf_c_boolean leave_running;
+  protobuf_c_boolean has_ext_unix_sk;
+  protobuf_c_boolean ext_unix_sk;
+  protobuf_c_boolean has_tcp_established;
+  protobuf_c_boolean tcp_established;
+  protobuf_c_boolean has_evasive_devices;
+  protobuf_c_boolean evasive_devices;
+  protobuf_c_boolean has_shell_job;
+  protobuf_c_boolean shell_job;
+  protobuf_c_boolean has_file_locks;
+  protobuf_c_boolean file_locks;
+  protobuf_c_boolean has_log_level;
+  int32_t log_level;
+  /*
+   * No subdirs are allowed. Consider using work-dir
+   */
+  char *log_file;
+  CriuPageServerInfo *ps;
+  protobuf_c_boolean has_notify_scripts;
+  protobuf_c_boolean notify_scripts;
+  char *root;
+  char *parent_img;
+  protobuf_c_boolean has_track_mem;
+  protobuf_c_boolean track_mem;
+  protobuf_c_boolean has_auto_dedup;
+  protobuf_c_boolean auto_dedup;
+  protobuf_c_boolean has_work_dir_fd;
+  int32_t work_dir_fd;
+  protobuf_c_boolean has_link_remap;
+  protobuf_c_boolean link_remap;
+  /*
+   * DEPRECATED, use external instead
+   */
+  size_t n_veths;
+  CriuVethPair **veths;
+  protobuf_c_boolean has_cpu_cap;
+  uint32_t cpu_cap;
+  protobuf_c_boolean has_force_irmap;
+  protobuf_c_boolean force_irmap;
+  size_t n_exec_cmd;
+  char **exec_cmd;
+  /*
+   * DEPRECATED, use external instead
+   */
+  size_t n_ext_mnt;
+  ExtMountMap **ext_mnt;
+  /*
+   * backward compatibility
+   */
+  protobuf_c_boolean has_manage_cgroups;
+  protobuf_c_boolean manage_cgroups;
+  size_t n_cg_root;
+  CgroupRoot **cg_root;
+  /*
+   * swrk only
+   */
+  protobuf_c_boolean has_rst_sibling;
+  protobuf_c_boolean rst_sibling;
+  /*
+   * swrk only
+   */
+  size_t n_inherit_fd;
+  InheritFd **inherit_fd;
+  protobuf_c_boolean has_auto_ext_mnt;
+  protobuf_c_boolean auto_ext_mnt;
+  protobuf_c_boolean has_ext_sharing;
+  protobuf_c_boolean ext_sharing;
+  protobuf_c_boolean has_ext_masters;
+  protobuf_c_boolean ext_masters;
+  size_t n_skip_mnt;
+  char **skip_mnt;
+  size_t n_enable_fs;
+  char **enable_fs;
+  /*
+   * DEPRECATED, use external instead
+   */
+  size_t n_unix_sk_ino;
+  UnixSk **unix_sk_ino;
+  protobuf_c_boolean has_manage_cgroups_mode;
+  CriuCgMode manage_cgroups_mode;
+  protobuf_c_boolean has_ghost_limit;
+  uint32_t ghost_limit;
+  size_t n_irmap_scan_paths;
+  char **irmap_scan_paths;
+  size_t n_external;
+  char **external;
+  protobuf_c_boolean has_empty_ns;
+  uint32_t empty_ns;
+  size_t n_join_ns;
+  JoinNamespace **join_ns;
+  char *cgroup_props;
+  char *cgroup_props_file;
+  size_t n_cgroup_dump_controller;
+  char **cgroup_dump_controller;
+  char *freeze_cgroup;
+  protobuf_c_boolean has_timeout;
+  uint32_t timeout;
+  protobuf_c_boolean has_tcp_skip_in_flight;
+  protobuf_c_boolean tcp_skip_in_flight;
+  protobuf_c_boolean has_weak_sysctls;
+  protobuf_c_boolean weak_sysctls;
+  protobuf_c_boolean has_lazy_pages;
+  protobuf_c_boolean lazy_pages;
+  protobuf_c_boolean has_status_fd;
+  int32_t status_fd;
+  protobuf_c_boolean has_orphan_pts_master;
+  protobuf_c_boolean orphan_pts_master;
+  char *config_file;
+  protobuf_c_boolean has_tcp_close;
+  protobuf_c_boolean tcp_close;
+  char *lsm_profile;
+  char *tls_cacert;
+  char *tls_cacrl;
+  char *tls_cert;
+  char *tls_key;
+  protobuf_c_boolean has_tls;
+  protobuf_c_boolean tls;
+  protobuf_c_boolean has_tls_no_cn_verify;
+  protobuf_c_boolean tls_no_cn_verify;
+  char *cgroup_yard;
+  /*
+   *	optional bool			check_mounts		= 128;
+   */
+  protobuf_c_boolean has_pre_dump_mode;
+  CriuPreDumpMode pre_dump_mode;
+};
+#define CRIU_OPTS__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_opts__descriptor) \
+    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, NULL, NULL, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0,NULL, 0, 4294967295u, 0, 0, 0,NULL, 0,NULL, 0, 0, 0,NULL, 0, 0, 0,NULL, 0, 0, 0, 0, 0, 0, 0,NULL, 0,NULL, 0,NULL, 0, CRIU_CG_MODE__IGNORE, 0, 1048576u, 0,NULL, 0,NULL, 0, 0, 0,NULL, NULL, NULL, 0,NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, 0, 0, NULL, NULL, NULL, NULL, NULL, 0, 0, 0, 0, NULL, 0, CRIU_PRE_DUMP_MODE__SPLICE }
+
+
+struct  _CriuDumpResp
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_restored;
+  protobuf_c_boolean restored;
+};
+#define CRIU_DUMP_RESP__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_dump_resp__descriptor) \
+    , 0, 0 }
+
+
+struct  _CriuRestoreResp
+{
+  ProtobufCMessage base;
+  int32_t pid;
+};
+#define CRIU_RESTORE_RESP__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_restore_resp__descriptor) \
+    , 0 }
+
+
+struct  _CriuNotify
+{
+  ProtobufCMessage base;
+  char *script;
+  protobuf_c_boolean has_pid;
+  int32_t pid;
+};
+#define CRIU_NOTIFY__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_notify__descriptor) \
+    , NULL, 0, 0 }
+
+
+/*
+ * List of features which can queried via
+ * CRIU_REQ_TYPE__FEATURE_CHECK
+ */
+struct  _CriuFeatures
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_mem_track;
+  protobuf_c_boolean mem_track;
+  protobuf_c_boolean has_lazy_pages;
+  protobuf_c_boolean lazy_pages;
+};
+#define CRIU_FEATURES__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_features__descriptor) \
+    , 0, 0, 0, 0 }
+
+
+struct  _CriuReq
+{
+  ProtobufCMessage base;
+  CriuReqType type;
+  CriuOpts *opts;
+  protobuf_c_boolean has_notify_success;
+  protobuf_c_boolean notify_success;
+  /*
+   * When set service won't close the connection but
+   * will wait for more req-s to appear. Works not
+   * for all request types.
+   */
+  protobuf_c_boolean has_keep_open;
+  protobuf_c_boolean keep_open;
+  /*
+   * 'features' can be used to query which features
+   * are supported by the installed criu/kernel
+   * via RPC.
+   */
+  CriuFeatures *features;
+  /*
+   * 'pid' is used for WAIT_PID
+   */
+  protobuf_c_boolean has_pid;
+  uint32_t pid;
+};
+#define CRIU_REQ__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_req__descriptor) \
+    , CRIU_REQ_TYPE__EMPTY, NULL, 0, 0, 0, 0, NULL, 0, 0 }
+
+
+struct  _CriuResp
+{
+  ProtobufCMessage base;
+  CriuReqType type;
+  protobuf_c_boolean success;
+  CriuDumpResp *dump;
+  CriuRestoreResp *restore;
+  CriuNotify *notify;
+  CriuPageServerInfo *ps;
+  protobuf_c_boolean has_cr_errno;
+  int32_t cr_errno;
+  CriuFeatures *features;
+  char *cr_errmsg;
+  CriuVersion *version;
+  protobuf_c_boolean has_status;
+  int32_t status;
+};
+#define CRIU_RESP__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_resp__descriptor) \
+    , CRIU_REQ_TYPE__EMPTY, 0, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, 0, 0 }
+
+
+/*
+ * Answer for criu_req_type.VERSION requests
+ */
+struct  _CriuVersion
+{
+  ProtobufCMessage base;
+  int32_t major_number;
+  int32_t minor_number;
+  char *gitid;
+  protobuf_c_boolean has_sublevel;
+  int32_t sublevel;
+  protobuf_c_boolean has_extra;
+  int32_t extra;
+  char *name;
+};
+#define CRIU_VERSION__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&criu_version__descriptor) \
+    , 0, 0, NULL, 0, 0, 0, 0, NULL }
+
+
+/* CriuPageServerInfo methods */
+void   criu_page_server_info__init
+                     (CriuPageServerInfo         *message);
+size_t criu_page_server_info__get_packed_size
+                     (const CriuPageServerInfo   *message);
+size_t criu_page_server_info__pack
+                     (const CriuPageServerInfo   *message,
+                      uint8_t             *out);
+size_t criu_page_server_info__pack_to_buffer
+                     (const CriuPageServerInfo   *message,
+                      ProtobufCBuffer     *buffer);
+CriuPageServerInfo *
+       criu_page_server_info__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_page_server_info__free_unpacked
+                     (CriuPageServerInfo *message,
+                      ProtobufCAllocator *allocator);
+/* CriuVethPair methods */
+void   criu_veth_pair__init
+                     (CriuVethPair         *message);
+size_t criu_veth_pair__get_packed_size
+                     (const CriuVethPair   *message);
+size_t criu_veth_pair__pack
+                     (const CriuVethPair   *message,
+                      uint8_t             *out);
+size_t criu_veth_pair__pack_to_buffer
+                     (const CriuVethPair   *message,
+                      ProtobufCBuffer     *buffer);
+CriuVethPair *
+       criu_veth_pair__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_veth_pair__free_unpacked
+                     (CriuVethPair *message,
+                      ProtobufCAllocator *allocator);
+/* ExtMountMap methods */
+void   ext_mount_map__init
+                     (ExtMountMap         *message);
+size_t ext_mount_map__get_packed_size
+                     (const ExtMountMap   *message);
+size_t ext_mount_map__pack
+                     (const ExtMountMap   *message,
+                      uint8_t             *out);
+size_t ext_mount_map__pack_to_buffer
+                     (const ExtMountMap   *message,
+                      ProtobufCBuffer     *buffer);
+ExtMountMap *
+       ext_mount_map__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   ext_mount_map__free_unpacked
+                     (ExtMountMap *message,
+                      ProtobufCAllocator *allocator);
+/* JoinNamespace methods */
+void   join_namespace__init
+                     (JoinNamespace         *message);
+size_t join_namespace__get_packed_size
+                     (const JoinNamespace   *message);
+size_t join_namespace__pack
+                     (const JoinNamespace   *message,
+                      uint8_t             *out);
+size_t join_namespace__pack_to_buffer
+                     (const JoinNamespace   *message,
+                      ProtobufCBuffer     *buffer);
+JoinNamespace *
+       join_namespace__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   join_namespace__free_unpacked
+                     (JoinNamespace *message,
+                      ProtobufCAllocator *allocator);
+/* InheritFd methods */
+void   inherit_fd__init
+                     (InheritFd         *message);
+size_t inherit_fd__get_packed_size
+                     (const InheritFd   *message);
+size_t inherit_fd__pack
+                     (const InheritFd   *message,
+                      uint8_t             *out);
+size_t inherit_fd__pack_to_buffer
+                     (const InheritFd   *message,
+                      ProtobufCBuffer     *buffer);
+InheritFd *
+       inherit_fd__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   inherit_fd__free_unpacked
+                     (InheritFd *message,
+                      ProtobufCAllocator *allocator);
+/* CgroupRoot methods */
+void   cgroup_root__init
+                     (CgroupRoot         *message);
+size_t cgroup_root__get_packed_size
+                     (const CgroupRoot   *message);
+size_t cgroup_root__pack
+                     (const CgroupRoot   *message,
+                      uint8_t             *out);
+size_t cgroup_root__pack_to_buffer
+                     (const CgroupRoot   *message,
+                      ProtobufCBuffer     *buffer);
+CgroupRoot *
+       cgroup_root__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   cgroup_root__free_unpacked
+                     (CgroupRoot *message,
+                      ProtobufCAllocator *allocator);
+/* UnixSk methods */
+void   unix_sk__init
+                     (UnixSk         *message);
+size_t unix_sk__get_packed_size
+                     (const UnixSk   *message);
+size_t unix_sk__pack
+                     (const UnixSk   *message,
+                      uint8_t             *out);
+size_t unix_sk__pack_to_buffer
+                     (const UnixSk   *message,
+                      ProtobufCBuffer     *buffer);
+UnixSk *
+       unix_sk__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   unix_sk__free_unpacked
+                     (UnixSk *message,
+                      ProtobufCAllocator *allocator);
+/* CriuOpts methods */
+void   criu_opts__init
+                     (CriuOpts         *message);
+size_t criu_opts__get_packed_size
+                     (const CriuOpts   *message);
+size_t criu_opts__pack
+                     (const CriuOpts   *message,
+                      uint8_t             *out);
+size_t criu_opts__pack_to_buffer
+                     (const CriuOpts   *message,
+                      ProtobufCBuffer     *buffer);
+CriuOpts *
+       criu_opts__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_opts__free_unpacked
+                     (CriuOpts *message,
+                      ProtobufCAllocator *allocator);
+/* CriuDumpResp methods */
+void   criu_dump_resp__init
+                     (CriuDumpResp         *message);
+size_t criu_dump_resp__get_packed_size
+                     (const CriuDumpResp   *message);
+size_t criu_dump_resp__pack
+                     (const CriuDumpResp   *message,
+                      uint8_t             *out);
+size_t criu_dump_resp__pack_to_buffer
+                     (const CriuDumpResp   *message,
+                      ProtobufCBuffer     *buffer);
+CriuDumpResp *
+       criu_dump_resp__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_dump_resp__free_unpacked
+                     (CriuDumpResp *message,
+                      ProtobufCAllocator *allocator);
+/* CriuRestoreResp methods */
+void   criu_restore_resp__init
+                     (CriuRestoreResp         *message);
+size_t criu_restore_resp__get_packed_size
+                     (const CriuRestoreResp   *message);
+size_t criu_restore_resp__pack
+                     (const CriuRestoreResp   *message,
+                      uint8_t             *out);
+size_t criu_restore_resp__pack_to_buffer
+                     (const CriuRestoreResp   *message,
+                      ProtobufCBuffer     *buffer);
+CriuRestoreResp *
+       criu_restore_resp__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_restore_resp__free_unpacked
+                     (CriuRestoreResp *message,
+                      ProtobufCAllocator *allocator);
+/* CriuNotify methods */
+void   criu_notify__init
+                     (CriuNotify         *message);
+size_t criu_notify__get_packed_size
+                     (const CriuNotify   *message);
+size_t criu_notify__pack
+                     (const CriuNotify   *message,
+                      uint8_t             *out);
+size_t criu_notify__pack_to_buffer
+                     (const CriuNotify   *message,
+                      ProtobufCBuffer     *buffer);
+CriuNotify *
+       criu_notify__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_notify__free_unpacked
+                     (CriuNotify *message,
+                      ProtobufCAllocator *allocator);
+/* CriuFeatures methods */
+void   criu_features__init
+                     (CriuFeatures         *message);
+size_t criu_features__get_packed_size
+                     (const CriuFeatures   *message);
+size_t criu_features__pack
+                     (const CriuFeatures   *message,
+                      uint8_t             *out);
+size_t criu_features__pack_to_buffer
+                     (const CriuFeatures   *message,
+                      ProtobufCBuffer     *buffer);
+CriuFeatures *
+       criu_features__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_features__free_unpacked
+                     (CriuFeatures *message,
+                      ProtobufCAllocator *allocator);
+/* CriuReq methods */
+void   criu_req__init
+                     (CriuReq         *message);
+size_t criu_req__get_packed_size
+                     (const CriuReq   *message);
+size_t criu_req__pack
+                     (const CriuReq   *message,
+                      uint8_t             *out);
+size_t criu_req__pack_to_buffer
+                     (const CriuReq   *message,
+                      ProtobufCBuffer     *buffer);
+CriuReq *
+       criu_req__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_req__free_unpacked
+                     (CriuReq *message,
+                      ProtobufCAllocator *allocator);
+/* CriuResp methods */
+void   criu_resp__init
+                     (CriuResp         *message);
+size_t criu_resp__get_packed_size
+                     (const CriuResp   *message);
+size_t criu_resp__pack
+                     (const CriuResp   *message,
+                      uint8_t             *out);
+size_t criu_resp__pack_to_buffer
+                     (const CriuResp   *message,
+                      ProtobufCBuffer     *buffer);
+CriuResp *
+       criu_resp__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_resp__free_unpacked
+                     (CriuResp *message,
+                      ProtobufCAllocator *allocator);
+/* CriuVersion methods */
+void   criu_version__init
+                     (CriuVersion         *message);
+size_t criu_version__get_packed_size
+                     (const CriuVersion   *message);
+size_t criu_version__pack
+                     (const CriuVersion   *message,
+                      uint8_t             *out);
+size_t criu_version__pack_to_buffer
+                     (const CriuVersion   *message,
+                      ProtobufCBuffer     *buffer);
+CriuVersion *
+       criu_version__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   criu_version__free_unpacked
+                     (CriuVersion *message,
+                      ProtobufCAllocator *allocator);
+/* --- per-message closures --- */
+
+typedef void (*CriuPageServerInfo_Closure)
+                 (const CriuPageServerInfo *message,
+                  void *closure_data);
+typedef void (*CriuVethPair_Closure)
+                 (const CriuVethPair *message,
+                  void *closure_data);
+typedef void (*ExtMountMap_Closure)
+                 (const ExtMountMap *message,
+                  void *closure_data);
+typedef void (*JoinNamespace_Closure)
+                 (const JoinNamespace *message,
+                  void *closure_data);
+typedef void (*InheritFd_Closure)
+                 (const InheritFd *message,
+                  void *closure_data);
+typedef void (*CgroupRoot_Closure)
+                 (const CgroupRoot *message,
+                  void *closure_data);
+typedef void (*UnixSk_Closure)
+                 (const UnixSk *message,
+                  void *closure_data);
+typedef void (*CriuOpts_Closure)
+                 (const CriuOpts *message,
+                  void *closure_data);
+typedef void (*CriuDumpResp_Closure)
+                 (const CriuDumpResp *message,
+                  void *closure_data);
+typedef void (*CriuRestoreResp_Closure)
+                 (const CriuRestoreResp *message,
+                  void *closure_data);
+typedef void (*CriuNotify_Closure)
+                 (const CriuNotify *message,
+                  void *closure_data);
+typedef void (*CriuFeatures_Closure)
+                 (const CriuFeatures *message,
+                  void *closure_data);
+typedef void (*CriuReq_Closure)
+                 (const CriuReq *message,
+                  void *closure_data);
+typedef void (*CriuResp_Closure)
+                 (const CriuResp *message,
+                  void *closure_data);
+typedef void (*CriuVersion_Closure)
+                 (const CriuVersion *message,
+                  void *closure_data);
+
+/* --- services --- */
+
+
+/* --- descriptors --- */
+
+extern const ProtobufCEnumDescriptor    criu_cg_mode__descriptor;
+extern const ProtobufCEnumDescriptor    criu_pre_dump_mode__descriptor;
+extern const ProtobufCEnumDescriptor    criu_req_type__descriptor;
+extern const ProtobufCMessageDescriptor criu_page_server_info__descriptor;
+extern const ProtobufCMessageDescriptor criu_veth_pair__descriptor;
+extern const ProtobufCMessageDescriptor ext_mount_map__descriptor;
+extern const ProtobufCMessageDescriptor join_namespace__descriptor;
+extern const ProtobufCMessageDescriptor inherit_fd__descriptor;
+extern const ProtobufCMessageDescriptor cgroup_root__descriptor;
+extern const ProtobufCMessageDescriptor unix_sk__descriptor;
+extern const ProtobufCMessageDescriptor criu_opts__descriptor;
+extern const ProtobufCMessageDescriptor criu_dump_resp__descriptor;
+extern const ProtobufCMessageDescriptor criu_restore_resp__descriptor;
+extern const ProtobufCMessageDescriptor criu_notify__descriptor;
+extern const ProtobufCMessageDescriptor criu_features__descriptor;
+extern const ProtobufCMessageDescriptor criu_req__descriptor;
+extern const ProtobufCMessageDescriptor criu_resp__descriptor;
+extern const ProtobufCMessageDescriptor criu_version__descriptor;
+
+PROTOBUF_C__END_DECLS
+
+
+#endif  /* PROTOBUF_C_rpc_2eproto__INCLUDED */
+
+/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
+/* Generated from: rpc.proto */
+
+/* Do not generate deprecated warnings for self */
+#ifndef PROTOBUF_C__NO_DEPRECATED
+#define PROTOBUF_C__NO_DEPRECATED
+#endif
+
+void   criu_page_server_info__init
+                     (CriuPageServerInfo         *message)
+{
+  static const CriuPageServerInfo init_value = CRIU_PAGE_SERVER_INFO__INIT;
+  *message = init_value;
+}
+size_t criu_page_server_info__get_packed_size
+                     (const CriuPageServerInfo *message)
+{
+  assert(message->base.descriptor == &criu_page_server_info__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_page_server_info__pack
+                     (const CriuPageServerInfo *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_page_server_info__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_page_server_info__pack_to_buffer
+                     (const CriuPageServerInfo *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_page_server_info__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuPageServerInfo *
+       criu_page_server_info__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuPageServerInfo *)
+     protobuf_c_message_unpack (&criu_page_server_info__descriptor,
+                                allocator, len, data);
+}
+void   criu_page_server_info__free_unpacked
+                     (CriuPageServerInfo *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_page_server_info__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_veth_pair__init
+                     (CriuVethPair         *message)
+{
+  static const CriuVethPair init_value = CRIU_VETH_PAIR__INIT;
+  *message = init_value;
+}
+size_t criu_veth_pair__get_packed_size
+                     (const CriuVethPair *message)
+{
+  assert(message->base.descriptor == &criu_veth_pair__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_veth_pair__pack
+                     (const CriuVethPair *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_veth_pair__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_veth_pair__pack_to_buffer
+                     (const CriuVethPair *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_veth_pair__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuVethPair *
+       criu_veth_pair__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuVethPair *)
+     protobuf_c_message_unpack (&criu_veth_pair__descriptor,
+                                allocator, len, data);
+}
+void   criu_veth_pair__free_unpacked
+                     (CriuVethPair *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_veth_pair__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   ext_mount_map__init
+                     (ExtMountMap         *message)
+{
+  static const ExtMountMap init_value = EXT_MOUNT_MAP__INIT;
+  *message = init_value;
+}
+size_t ext_mount_map__get_packed_size
+                     (const ExtMountMap *message)
+{
+  assert(message->base.descriptor == &ext_mount_map__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t ext_mount_map__pack
+                     (const ExtMountMap *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &ext_mount_map__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t ext_mount_map__pack_to_buffer
+                     (const ExtMountMap *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &ext_mount_map__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+ExtMountMap *
+       ext_mount_map__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (ExtMountMap *)
+     protobuf_c_message_unpack (&ext_mount_map__descriptor,
+                                allocator, len, data);
+}
+void   ext_mount_map__free_unpacked
+                     (ExtMountMap *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &ext_mount_map__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   join_namespace__init
+                     (JoinNamespace         *message)
+{
+  static const JoinNamespace init_value = JOIN_NAMESPACE__INIT;
+  *message = init_value;
+}
+size_t join_namespace__get_packed_size
+                     (const JoinNamespace *message)
+{
+  assert(message->base.descriptor == &join_namespace__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t join_namespace__pack
+                     (const JoinNamespace *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &join_namespace__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t join_namespace__pack_to_buffer
+                     (const JoinNamespace *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &join_namespace__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+JoinNamespace *
+       join_namespace__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (JoinNamespace *)
+     protobuf_c_message_unpack (&join_namespace__descriptor,
+                                allocator, len, data);
+}
+void   join_namespace__free_unpacked
+                     (JoinNamespace *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &join_namespace__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   inherit_fd__init
+                     (InheritFd         *message)
+{
+  static const InheritFd init_value = INHERIT_FD__INIT;
+  *message = init_value;
+}
+size_t inherit_fd__get_packed_size
+                     (const InheritFd *message)
+{
+  assert(message->base.descriptor == &inherit_fd__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t inherit_fd__pack
+                     (const InheritFd *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &inherit_fd__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t inherit_fd__pack_to_buffer
+                     (const InheritFd *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &inherit_fd__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+InheritFd *
+       inherit_fd__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (InheritFd *)
+     protobuf_c_message_unpack (&inherit_fd__descriptor,
+                                allocator, len, data);
+}
+void   inherit_fd__free_unpacked
+                     (InheritFd *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &inherit_fd__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   cgroup_root__init
+                     (CgroupRoot         *message)
+{
+  static const CgroupRoot init_value = CGROUP_ROOT__INIT;
+  *message = init_value;
+}
+size_t cgroup_root__get_packed_size
+                     (const CgroupRoot *message)
+{
+  assert(message->base.descriptor == &cgroup_root__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t cgroup_root__pack
+                     (const CgroupRoot *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &cgroup_root__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t cgroup_root__pack_to_buffer
+                     (const CgroupRoot *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &cgroup_root__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CgroupRoot *
+       cgroup_root__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CgroupRoot *)
+     protobuf_c_message_unpack (&cgroup_root__descriptor,
+                                allocator, len, data);
+}
+void   cgroup_root__free_unpacked
+                     (CgroupRoot *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &cgroup_root__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   unix_sk__init
+                     (UnixSk         *message)
+{
+  static const UnixSk init_value = UNIX_SK__INIT;
+  *message = init_value;
+}
+size_t unix_sk__get_packed_size
+                     (const UnixSk *message)
+{
+  assert(message->base.descriptor == &unix_sk__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t unix_sk__pack
+                     (const UnixSk *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &unix_sk__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t unix_sk__pack_to_buffer
+                     (const UnixSk *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &unix_sk__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+UnixSk *
+       unix_sk__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (UnixSk *)
+     protobuf_c_message_unpack (&unix_sk__descriptor,
+                                allocator, len, data);
+}
+void   unix_sk__free_unpacked
+                     (UnixSk *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &unix_sk__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_opts__init
+                     (CriuOpts         *message)
+{
+  static const CriuOpts init_value = CRIU_OPTS__INIT;
+  *message = init_value;
+}
+size_t criu_opts__get_packed_size
+                     (const CriuOpts *message)
+{
+  assert(message->base.descriptor == &criu_opts__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_opts__pack
+                     (const CriuOpts *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_opts__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_opts__pack_to_buffer
+                     (const CriuOpts *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_opts__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuOpts *
+       criu_opts__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuOpts *)
+     protobuf_c_message_unpack (&criu_opts__descriptor,
+                                allocator, len, data);
+}
+void   criu_opts__free_unpacked
+                     (CriuOpts *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_opts__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_dump_resp__init
+                     (CriuDumpResp         *message)
+{
+  static const CriuDumpResp init_value = CRIU_DUMP_RESP__INIT;
+  *message = init_value;
+}
+size_t criu_dump_resp__get_packed_size
+                     (const CriuDumpResp *message)
+{
+  assert(message->base.descriptor == &criu_dump_resp__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_dump_resp__pack
+                     (const CriuDumpResp *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_dump_resp__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_dump_resp__pack_to_buffer
+                     (const CriuDumpResp *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_dump_resp__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuDumpResp *
+       criu_dump_resp__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuDumpResp *)
+     protobuf_c_message_unpack (&criu_dump_resp__descriptor,
+                                allocator, len, data);
+}
+void   criu_dump_resp__free_unpacked
+                     (CriuDumpResp *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_dump_resp__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_restore_resp__init
+                     (CriuRestoreResp         *message)
+{
+  static const CriuRestoreResp init_value = CRIU_RESTORE_RESP__INIT;
+  *message = init_value;
+}
+size_t criu_restore_resp__get_packed_size
+                     (const CriuRestoreResp *message)
+{
+  assert(message->base.descriptor == &criu_restore_resp__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_restore_resp__pack
+                     (const CriuRestoreResp *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_restore_resp__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_restore_resp__pack_to_buffer
+                     (const CriuRestoreResp *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_restore_resp__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuRestoreResp *
+       criu_restore_resp__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuRestoreResp *)
+     protobuf_c_message_unpack (&criu_restore_resp__descriptor,
+                                allocator, len, data);
+}
+void   criu_restore_resp__free_unpacked
+                     (CriuRestoreResp *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_restore_resp__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_notify__init
+                     (CriuNotify         *message)
+{
+  static const CriuNotify init_value = CRIU_NOTIFY__INIT;
+  *message = init_value;
+}
+size_t criu_notify__get_packed_size
+                     (const CriuNotify *message)
+{
+  assert(message->base.descriptor == &criu_notify__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_notify__pack
+                     (const CriuNotify *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_notify__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_notify__pack_to_buffer
+                     (const CriuNotify *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_notify__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuNotify *
+       criu_notify__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuNotify *)
+     protobuf_c_message_unpack (&criu_notify__descriptor,
+                                allocator, len, data);
+}
+void   criu_notify__free_unpacked
+                     (CriuNotify *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_notify__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_features__init
+                     (CriuFeatures         *message)
+{
+  static const CriuFeatures init_value = CRIU_FEATURES__INIT;
+  *message = init_value;
+}
+size_t criu_features__get_packed_size
+                     (const CriuFeatures *message)
+{
+  assert(message->base.descriptor == &criu_features__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_features__pack
+                     (const CriuFeatures *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_features__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_features__pack_to_buffer
+                     (const CriuFeatures *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_features__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuFeatures *
+       criu_features__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuFeatures *)
+     protobuf_c_message_unpack (&criu_features__descriptor,
+                                allocator, len, data);
+}
+void   criu_features__free_unpacked
+                     (CriuFeatures *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_features__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_req__init
+                     (CriuReq         *message)
+{
+  static const CriuReq init_value = CRIU_REQ__INIT;
+  *message = init_value;
+}
+size_t criu_req__get_packed_size
+                     (const CriuReq *message)
+{
+  assert(message->base.descriptor == &criu_req__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_req__pack
+                     (const CriuReq *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_req__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_req__pack_to_buffer
+                     (const CriuReq *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_req__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuReq *
+       criu_req__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuReq *)
+     protobuf_c_message_unpack (&criu_req__descriptor,
+                                allocator, len, data);
+}
+void   criu_req__free_unpacked
+                     (CriuReq *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_req__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_resp__init
+                     (CriuResp         *message)
+{
+  static const CriuResp init_value = CRIU_RESP__INIT;
+  *message = init_value;
+}
+size_t criu_resp__get_packed_size
+                     (const CriuResp *message)
+{
+  assert(message->base.descriptor == &criu_resp__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_resp__pack
+                     (const CriuResp *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_resp__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_resp__pack_to_buffer
+                     (const CriuResp *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_resp__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuResp *
+       criu_resp__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuResp *)
+     protobuf_c_message_unpack (&criu_resp__descriptor,
+                                allocator, len, data);
+}
+void   criu_resp__free_unpacked
+                     (CriuResp *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_resp__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   criu_version__init
+                     (CriuVersion         *message)
+{
+  static const CriuVersion init_value = CRIU_VERSION__INIT;
+  *message = init_value;
+}
+size_t criu_version__get_packed_size
+                     (const CriuVersion *message)
+{
+  assert(message->base.descriptor == &criu_version__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t criu_version__pack
+                     (const CriuVersion *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &criu_version__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t criu_version__pack_to_buffer
+                     (const CriuVersion *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &criu_version__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+CriuVersion *
+       criu_version__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (CriuVersion *)
+     protobuf_c_message_unpack (&criu_version__descriptor,
+                                allocator, len, data);
+}
+void   criu_version__free_unpacked
+                     (CriuVersion *message,
+                      ProtobufCAllocator *allocator)
+{
+  if(!message)
+    return;
+  assert(message->base.descriptor == &criu_version__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+static const ProtobufCFieldDescriptor criu_page_server_info__field_descriptors[4] =
+{
+  {
+    "address",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuPageServerInfo, address),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "port",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuPageServerInfo, has_port),
+    offsetof(CriuPageServerInfo, port),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "pid",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuPageServerInfo, has_pid),
+    offsetof(CriuPageServerInfo, pid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "fd",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuPageServerInfo, has_fd),
+    offsetof(CriuPageServerInfo, fd),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_page_server_info__field_indices_by_name[] = {
+  0,   /* field[0] = address */
+  3,   /* field[3] = fd */
+  2,   /* field[2] = pid */
+  1,   /* field[1] = port */
+};
+static const ProtobufCIntRange criu_page_server_info__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 4 }
+};
+const ProtobufCMessageDescriptor criu_page_server_info__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_page_server_info",
+  "CriuPageServerInfo",
+  "CriuPageServerInfo",
+  "",
+  sizeof(CriuPageServerInfo),
+  4,
+  criu_page_server_info__field_descriptors,
+  criu_page_server_info__field_indices_by_name,
+  1,  criu_page_server_info__number_ranges,
+  (ProtobufCMessageInit) criu_page_server_info__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_veth_pair__field_descriptors[2] =
+{
+  {
+    "if_in",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuVethPair, if_in),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "if_out",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuVethPair, if_out),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_veth_pair__field_indices_by_name[] = {
+  0,   /* field[0] = if_in */
+  1,   /* field[1] = if_out */
+};
+static const ProtobufCIntRange criu_veth_pair__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 2 }
+};
+const ProtobufCMessageDescriptor criu_veth_pair__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_veth_pair",
+  "CriuVethPair",
+  "CriuVethPair",
+  "",
+  sizeof(CriuVethPair),
+  2,
+  criu_veth_pair__field_descriptors,
+  criu_veth_pair__field_indices_by_name,
+  1,  criu_veth_pair__number_ranges,
+  (ProtobufCMessageInit) criu_veth_pair__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor ext_mount_map__field_descriptors[2] =
+{
+  {
+    "key",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(ExtMountMap, key),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "val",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(ExtMountMap, val),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned ext_mount_map__field_indices_by_name[] = {
+  0,   /* field[0] = key */
+  1,   /* field[1] = val */
+};
+static const ProtobufCIntRange ext_mount_map__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 2 }
+};
+const ProtobufCMessageDescriptor ext_mount_map__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "ext_mount_map",
+  "ExtMountMap",
+  "ExtMountMap",
+  "",
+  sizeof(ExtMountMap),
+  2,
+  ext_mount_map__field_descriptors,
+  ext_mount_map__field_indices_by_name,
+  1,  ext_mount_map__number_ranges,
+  (ProtobufCMessageInit) ext_mount_map__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor join_namespace__field_descriptors[3] =
+{
+  {
+    "ns",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(JoinNamespace, ns),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ns_file",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(JoinNamespace, ns_file),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "extra_opt",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(JoinNamespace, extra_opt),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned join_namespace__field_indices_by_name[] = {
+  2,   /* field[2] = extra_opt */
+  0,   /* field[0] = ns */
+  1,   /* field[1] = ns_file */
+};
+static const ProtobufCIntRange join_namespace__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 3 }
+};
+const ProtobufCMessageDescriptor join_namespace__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "join_namespace",
+  "JoinNamespace",
+  "JoinNamespace",
+  "",
+  sizeof(JoinNamespace),
+  3,
+  join_namespace__field_descriptors,
+  join_namespace__field_indices_by_name,
+  1,  join_namespace__number_ranges,
+  (ProtobufCMessageInit) join_namespace__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor inherit_fd__field_descriptors[2] =
+{
+  {
+    "key",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(InheritFd, key),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "fd",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_INT32,
+    0,   /* quantifier_offset */
+    offsetof(InheritFd, fd),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned inherit_fd__field_indices_by_name[] = {
+  1,   /* field[1] = fd */
+  0,   /* field[0] = key */
+};
+static const ProtobufCIntRange inherit_fd__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 2 }
+};
+const ProtobufCMessageDescriptor inherit_fd__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "inherit_fd",
+  "InheritFd",
+  "InheritFd",
+  "",
+  sizeof(InheritFd),
+  2,
+  inherit_fd__field_descriptors,
+  inherit_fd__field_indices_by_name,
+  1,  inherit_fd__number_ranges,
+  (ProtobufCMessageInit) inherit_fd__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor cgroup_root__field_descriptors[2] =
+{
+  {
+    "ctrl",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CgroupRoot, ctrl),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "path",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CgroupRoot, path),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned cgroup_root__field_indices_by_name[] = {
+  0,   /* field[0] = ctrl */
+  1,   /* field[1] = path */
+};
+static const ProtobufCIntRange cgroup_root__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 2 }
+};
+const ProtobufCMessageDescriptor cgroup_root__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "cgroup_root",
+  "CgroupRoot",
+  "CgroupRoot",
+  "",
+  sizeof(CgroupRoot),
+  2,
+  cgroup_root__field_descriptors,
+  cgroup_root__field_indices_by_name,
+  1,  cgroup_root__number_ranges,
+  (ProtobufCMessageInit) cgroup_root__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor unix_sk__field_descriptors[1] =
+{
+  {
+    "inode",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_UINT32,
+    0,   /* quantifier_offset */
+    offsetof(UnixSk, inode),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned unix_sk__field_indices_by_name[] = {
+  0,   /* field[0] = inode */
+};
+static const ProtobufCIntRange unix_sk__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 1 }
+};
+const ProtobufCMessageDescriptor unix_sk__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "unix_sk",
+  "UnixSk",
+  "UnixSk",
+  "",
+  sizeof(UnixSk),
+  1,
+  unix_sk__field_descriptors,
+  unix_sk__field_indices_by_name,
+  1,  unix_sk__number_ranges,
+  (ProtobufCMessageInit) unix_sk__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const int32_t criu_opts__log_level__default_value = 2;
+static const uint32_t criu_opts__cpu_cap__default_value = 4294967295u;
+static const uint32_t criu_opts__ghost_limit__default_value = 1048576u;
+static const CriuPreDumpMode criu_opts__pre_dump_mode__default_value = CRIU_PRE_DUMP_MODE__SPLICE;
+static const ProtobufCFieldDescriptor criu_opts__field_descriptors[60] =
+{
+  {
+    "images_dir_fd",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_INT32,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, images_dir_fd),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "pid",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuOpts, has_pid),
+    offsetof(CriuOpts, pid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "leave_running",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_leave_running),
+    offsetof(CriuOpts, leave_running),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ext_unix_sk",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_ext_unix_sk),
+    offsetof(CriuOpts, ext_unix_sk),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tcp_established",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_tcp_established),
+    offsetof(CriuOpts, tcp_established),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "evasive_devices",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_evasive_devices),
+    offsetof(CriuOpts, evasive_devices),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "shell_job",
+    7,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_shell_job),
+    offsetof(CriuOpts, shell_job),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "file_locks",
+    8,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_file_locks),
+    offsetof(CriuOpts, file_locks),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "log_level",
+    9,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuOpts, has_log_level),
+    offsetof(CriuOpts, log_level),
+    NULL,
+    &criu_opts__log_level__default_value,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "log_file",
+    10,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, log_file),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ps",
+    11,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, ps),
+    &criu_page_server_info__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "notify_scripts",
+    12,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_notify_scripts),
+    offsetof(CriuOpts, notify_scripts),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "root",
+    13,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, root),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "parent_img",
+    14,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, parent_img),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "track_mem",
+    15,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_track_mem),
+    offsetof(CriuOpts, track_mem),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "auto_dedup",
+    16,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_auto_dedup),
+    offsetof(CriuOpts, auto_dedup),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "work_dir_fd",
+    17,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuOpts, has_work_dir_fd),
+    offsetof(CriuOpts, work_dir_fd),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "link_remap",
+    18,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_link_remap),
+    offsetof(CriuOpts, link_remap),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "veths",
+    19,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(CriuOpts, n_veths),
+    offsetof(CriuOpts, veths),
+    &criu_veth_pair__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cpu_cap",
+    20,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(CriuOpts, has_cpu_cap),
+    offsetof(CriuOpts, cpu_cap),
+    NULL,
+    &criu_opts__cpu_cap__default_value,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "force_irmap",
+    21,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_force_irmap),
+    offsetof(CriuOpts, force_irmap),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "exec_cmd",
+    22,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_STRING,
+    offsetof(CriuOpts, n_exec_cmd),
+    offsetof(CriuOpts, exec_cmd),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ext_mnt",
+    23,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(CriuOpts, n_ext_mnt),
+    offsetof(CriuOpts, ext_mnt),
+    &ext_mount_map__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "manage_cgroups",
+    24,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_manage_cgroups),
+    offsetof(CriuOpts, manage_cgroups),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cg_root",
+    25,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(CriuOpts, n_cg_root),
+    offsetof(CriuOpts, cg_root),
+    &cgroup_root__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "rst_sibling",
+    26,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_rst_sibling),
+    offsetof(CriuOpts, rst_sibling),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "inherit_fd",
+    27,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(CriuOpts, n_inherit_fd),
+    offsetof(CriuOpts, inherit_fd),
+    &inherit_fd__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "auto_ext_mnt",
+    28,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_auto_ext_mnt),
+    offsetof(CriuOpts, auto_ext_mnt),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ext_sharing",
+    29,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_ext_sharing),
+    offsetof(CriuOpts, ext_sharing),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ext_masters",
+    30,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_ext_masters),
+    offsetof(CriuOpts, ext_masters),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "skip_mnt",
+    31,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_STRING,
+    offsetof(CriuOpts, n_skip_mnt),
+    offsetof(CriuOpts, skip_mnt),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "enable_fs",
+    32,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_STRING,
+    offsetof(CriuOpts, n_enable_fs),
+    offsetof(CriuOpts, enable_fs),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "unix_sk_ino",
+    33,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(CriuOpts, n_unix_sk_ino),
+    offsetof(CriuOpts, unix_sk_ino),
+    &unix_sk__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "manage_cgroups_mode",
+    34,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(CriuOpts, has_manage_cgroups_mode),
+    offsetof(CriuOpts, manage_cgroups_mode),
+    &criu_cg_mode__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ghost_limit",
+    35,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(CriuOpts, has_ghost_limit),
+    offsetof(CriuOpts, ghost_limit),
+    NULL,
+    &criu_opts__ghost_limit__default_value,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "irmap_scan_paths",
+    36,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_STRING,
+    offsetof(CriuOpts, n_irmap_scan_paths),
+    offsetof(CriuOpts, irmap_scan_paths),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "external",
+    37,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_STRING,
+    offsetof(CriuOpts, n_external),
+    offsetof(CriuOpts, external),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "empty_ns",
+    38,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(CriuOpts, has_empty_ns),
+    offsetof(CriuOpts, empty_ns),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "join_ns",
+    39,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(CriuOpts, n_join_ns),
+    offsetof(CriuOpts, join_ns),
+    &join_namespace__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cgroup_props",
+    41,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, cgroup_props),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cgroup_props_file",
+    42,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, cgroup_props_file),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cgroup_dump_controller",
+    43,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_STRING,
+    offsetof(CriuOpts, n_cgroup_dump_controller),
+    offsetof(CriuOpts, cgroup_dump_controller),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "freeze_cgroup",
+    44,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, freeze_cgroup),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "timeout",
+    45,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(CriuOpts, has_timeout),
+    offsetof(CriuOpts, timeout),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tcp_skip_in_flight",
+    46,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_tcp_skip_in_flight),
+    offsetof(CriuOpts, tcp_skip_in_flight),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "weak_sysctls",
+    47,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_weak_sysctls),
+    offsetof(CriuOpts, weak_sysctls),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "lazy_pages",
+    48,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_lazy_pages),
+    offsetof(CriuOpts, lazy_pages),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "status_fd",
+    49,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuOpts, has_status_fd),
+    offsetof(CriuOpts, status_fd),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "orphan_pts_master",
+    50,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_orphan_pts_master),
+    offsetof(CriuOpts, orphan_pts_master),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "config_file",
+    51,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, config_file),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tcp_close",
+    52,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_tcp_close),
+    offsetof(CriuOpts, tcp_close),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "lsm_profile",
+    53,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, lsm_profile),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tls_cacert",
+    54,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, tls_cacert),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tls_cacrl",
+    55,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, tls_cacrl),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tls_cert",
+    56,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, tls_cert),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tls_key",
+    57,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, tls_key),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tls",
+    58,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_tls),
+    offsetof(CriuOpts, tls),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "tls_no_cn_verify",
+    59,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuOpts, has_tls_no_cn_verify),
+    offsetof(CriuOpts, tls_no_cn_verify),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cgroup_yard",
+    60,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuOpts, cgroup_yard),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "pre_dump_mode",
+    61,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(CriuOpts, has_pre_dump_mode),
+    offsetof(CriuOpts, pre_dump_mode),
+    &criu_pre_dump_mode__descriptor,
+    &criu_opts__pre_dump_mode__default_value,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_opts__field_indices_by_name[] = {
+  15,   /* field[15] = auto_dedup */
+  27,   /* field[27] = auto_ext_mnt */
+  24,   /* field[24] = cg_root */
+  41,   /* field[41] = cgroup_dump_controller */
+  39,   /* field[39] = cgroup_props */
+  40,   /* field[40] = cgroup_props_file */
+  58,   /* field[58] = cgroup_yard */
+  49,   /* field[49] = config_file */
+  19,   /* field[19] = cpu_cap */
+  37,   /* field[37] = empty_ns */
+  31,   /* field[31] = enable_fs */
+  5,   /* field[5] = evasive_devices */
+  21,   /* field[21] = exec_cmd */
+  29,   /* field[29] = ext_masters */
+  22,   /* field[22] = ext_mnt */
+  28,   /* field[28] = ext_sharing */
+  3,   /* field[3] = ext_unix_sk */
+  36,   /* field[36] = external */
+  7,   /* field[7] = file_locks */
+  20,   /* field[20] = force_irmap */
+  42,   /* field[42] = freeze_cgroup */
+  34,   /* field[34] = ghost_limit */
+  0,   /* field[0] = images_dir_fd */
+  26,   /* field[26] = inherit_fd */
+  35,   /* field[35] = irmap_scan_paths */
+  38,   /* field[38] = join_ns */
+  46,   /* field[46] = lazy_pages */
+  2,   /* field[2] = leave_running */
+  17,   /* field[17] = link_remap */
+  9,   /* field[9] = log_file */
+  8,   /* field[8] = log_level */
+  51,   /* field[51] = lsm_profile */
+  23,   /* field[23] = manage_cgroups */
+  33,   /* field[33] = manage_cgroups_mode */
+  11,   /* field[11] = notify_scripts */
+  48,   /* field[48] = orphan_pts_master */
+  13,   /* field[13] = parent_img */
+  1,   /* field[1] = pid */
+  59,   /* field[59] = pre_dump_mode */
+  10,   /* field[10] = ps */
+  12,   /* field[12] = root */
+  25,   /* field[25] = rst_sibling */
+  6,   /* field[6] = shell_job */
+  30,   /* field[30] = skip_mnt */
+  47,   /* field[47] = status_fd */
+  50,   /* field[50] = tcp_close */
+  4,   /* field[4] = tcp_established */
+  44,   /* field[44] = tcp_skip_in_flight */
+  43,   /* field[43] = timeout */
+  56,   /* field[56] = tls */
+  52,   /* field[52] = tls_cacert */
+  53,   /* field[53] = tls_cacrl */
+  54,   /* field[54] = tls_cert */
+  55,   /* field[55] = tls_key */
+  57,   /* field[57] = tls_no_cn_verify */
+  14,   /* field[14] = track_mem */
+  32,   /* field[32] = unix_sk_ino */
+  18,   /* field[18] = veths */
+  45,   /* field[45] = weak_sysctls */
+  16,   /* field[16] = work_dir_fd */
+};
+static const ProtobufCIntRange criu_opts__number_ranges[2 + 1] =
+{
+  { 1, 0 },
+  { 41, 39 },
+  { 0, 60 }
+};
+const ProtobufCMessageDescriptor criu_opts__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_opts",
+  "CriuOpts",
+  "CriuOpts",
+  "",
+  sizeof(CriuOpts),
+  60,
+  criu_opts__field_descriptors,
+  criu_opts__field_indices_by_name,
+  2,  criu_opts__number_ranges,
+  (ProtobufCMessageInit) criu_opts__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_dump_resp__field_descriptors[1] =
+{
+  {
+    "restored",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuDumpResp, has_restored),
+    offsetof(CriuDumpResp, restored),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_dump_resp__field_indices_by_name[] = {
+  0,   /* field[0] = restored */
+};
+static const ProtobufCIntRange criu_dump_resp__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 1 }
+};
+const ProtobufCMessageDescriptor criu_dump_resp__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_dump_resp",
+  "CriuDumpResp",
+  "CriuDumpResp",
+  "",
+  sizeof(CriuDumpResp),
+  1,
+  criu_dump_resp__field_descriptors,
+  criu_dump_resp__field_indices_by_name,
+  1,  criu_dump_resp__number_ranges,
+  (ProtobufCMessageInit) criu_dump_resp__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_restore_resp__field_descriptors[1] =
+{
+  {
+    "pid",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_INT32,
+    0,   /* quantifier_offset */
+    offsetof(CriuRestoreResp, pid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_restore_resp__field_indices_by_name[] = {
+  0,   /* field[0] = pid */
+};
+static const ProtobufCIntRange criu_restore_resp__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 1 }
+};
+const ProtobufCMessageDescriptor criu_restore_resp__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_restore_resp",
+  "CriuRestoreResp",
+  "CriuRestoreResp",
+  "",
+  sizeof(CriuRestoreResp),
+  1,
+  criu_restore_resp__field_descriptors,
+  criu_restore_resp__field_indices_by_name,
+  1,  criu_restore_resp__number_ranges,
+  (ProtobufCMessageInit) criu_restore_resp__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_notify__field_descriptors[2] =
+{
+  {
+    "script",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuNotify, script),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "pid",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuNotify, has_pid),
+    offsetof(CriuNotify, pid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_notify__field_indices_by_name[] = {
+  1,   /* field[1] = pid */
+  0,   /* field[0] = script */
+};
+static const ProtobufCIntRange criu_notify__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 2 }
+};
+const ProtobufCMessageDescriptor criu_notify__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_notify",
+  "CriuNotify",
+  "CriuNotify",
+  "",
+  sizeof(CriuNotify),
+  2,
+  criu_notify__field_descriptors,
+  criu_notify__field_indices_by_name,
+  1,  criu_notify__number_ranges,
+  (ProtobufCMessageInit) criu_notify__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_features__field_descriptors[2] =
+{
+  {
+    "mem_track",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuFeatures, has_mem_track),
+    offsetof(CriuFeatures, mem_track),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "lazy_pages",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuFeatures, has_lazy_pages),
+    offsetof(CriuFeatures, lazy_pages),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_features__field_indices_by_name[] = {
+  1,   /* field[1] = lazy_pages */
+  0,   /* field[0] = mem_track */
+};
+static const ProtobufCIntRange criu_features__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 2 }
+};
+const ProtobufCMessageDescriptor criu_features__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_features",
+  "CriuFeatures",
+  "CriuFeatures",
+  "",
+  sizeof(CriuFeatures),
+  2,
+  criu_features__field_descriptors,
+  criu_features__field_indices_by_name,
+  1,  criu_features__number_ranges,
+  (ProtobufCMessageInit) criu_features__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_req__field_descriptors[6] =
+{
+  {
+    "type",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_ENUM,
+    0,   /* quantifier_offset */
+    offsetof(CriuReq, type),
+    &criu_req_type__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "opts",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuReq, opts),
+    &criu_opts__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "notify_success",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuReq, has_notify_success),
+    offsetof(CriuReq, notify_success),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "keep_open",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BOOL,
+    offsetof(CriuReq, has_keep_open),
+    offsetof(CriuReq, keep_open),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "features",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuReq, features),
+    &criu_features__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "pid",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(CriuReq, has_pid),
+    offsetof(CriuReq, pid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_req__field_indices_by_name[] = {
+  4,   /* field[4] = features */
+  3,   /* field[3] = keep_open */
+  2,   /* field[2] = notify_success */
+  1,   /* field[1] = opts */
+  5,   /* field[5] = pid */
+  0,   /* field[0] = type */
+};
+static const ProtobufCIntRange criu_req__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 6 }
+};
+const ProtobufCMessageDescriptor criu_req__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_req",
+  "CriuReq",
+  "CriuReq",
+  "",
+  sizeof(CriuReq),
+  6,
+  criu_req__field_descriptors,
+  criu_req__field_indices_by_name,
+  1,  criu_req__number_ranges,
+  (ProtobufCMessageInit) criu_req__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_resp__field_descriptors[11] =
+{
+  {
+    "type",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_ENUM,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, type),
+    &criu_req_type__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "success",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_BOOL,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, success),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "dump",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, dump),
+    &criu_dump_resp__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "restore",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, restore),
+    &criu_restore_resp__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "notify",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, notify),
+    &criu_notify__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "ps",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, ps),
+    &criu_page_server_info__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cr_errno",
+    7,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuResp, has_cr_errno),
+    offsetof(CriuResp, cr_errno),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "features",
+    8,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, features),
+    &criu_features__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "cr_errmsg",
+    9,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, cr_errmsg),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "version",
+    10,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(CriuResp, version),
+    &criu_version__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "status",
+    11,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuResp, has_status),
+    offsetof(CriuResp, status),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_resp__field_indices_by_name[] = {
+  8,   /* field[8] = cr_errmsg */
+  6,   /* field[6] = cr_errno */
+  2,   /* field[2] = dump */
+  7,   /* field[7] = features */
+  4,   /* field[4] = notify */
+  5,   /* field[5] = ps */
+  3,   /* field[3] = restore */
+  10,   /* field[10] = status */
+  1,   /* field[1] = success */
+  0,   /* field[0] = type */
+  9,   /* field[9] = version */
+};
+static const ProtobufCIntRange criu_resp__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 11 }
+};
+const ProtobufCMessageDescriptor criu_resp__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_resp",
+  "CriuResp",
+  "CriuResp",
+  "",
+  sizeof(CriuResp),
+  11,
+  criu_resp__field_descriptors,
+  criu_resp__field_indices_by_name,
+  1,  criu_resp__number_ranges,
+  (ProtobufCMessageInit) criu_resp__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor criu_version__field_descriptors[6] =
+{
+  {
+    "major_number",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_INT32,
+    0,   /* quantifier_offset */
+    offsetof(CriuVersion, major_number),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "minor_number",
+    2,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_INT32,
+    0,   /* quantifier_offset */
+    offsetof(CriuVersion, minor_number),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "gitid",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuVersion, gitid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "sublevel",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuVersion, has_sublevel),
+    offsetof(CriuVersion, sublevel),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "extra",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_INT32,
+    offsetof(CriuVersion, has_extra),
+    offsetof(CriuVersion, extra),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "name",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(CriuVersion, name),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned criu_version__field_indices_by_name[] = {
+  4,   /* field[4] = extra */
+  2,   /* field[2] = gitid */
+  0,   /* field[0] = major_number */
+  1,   /* field[1] = minor_number */
+  5,   /* field[5] = name */
+  3,   /* field[3] = sublevel */
+};
+static const ProtobufCIntRange criu_version__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 6 }
+};
+const ProtobufCMessageDescriptor criu_version__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "criu_version",
+  "CriuVersion",
+  "CriuVersion",
+  "",
+  sizeof(CriuVersion),
+  6,
+  criu_version__field_descriptors,
+  criu_version__field_indices_by_name,
+  1,  criu_version__number_ranges,
+  (ProtobufCMessageInit) criu_version__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCEnumValue criu_cg_mode__enum_values_by_number[7] =
+{
+  { "IGNORE", "CRIU_CG_MODE__IGNORE", 0 },
+  { "CG_NONE", "CRIU_CG_MODE__CG_NONE", 1 },
+  { "PROPS", "CRIU_CG_MODE__PROPS", 2 },
+  { "SOFT", "CRIU_CG_MODE__SOFT", 3 },
+  { "FULL", "CRIU_CG_MODE__FULL", 4 },
+  { "STRICT", "CRIU_CG_MODE__STRICT", 5 },
+  { "DEFAULT", "CRIU_CG_MODE__DEFAULT", 6 },
+};
+static const ProtobufCIntRange criu_cg_mode__value_ranges[] = {
+{0, 0},{0, 7}
+};
+static const ProtobufCEnumValueIndex criu_cg_mode__enum_values_by_name[7] =
+{
+  { "CG_NONE", 1 },
+  { "DEFAULT", 6 },
+  { "FULL", 4 },
+  { "IGNORE", 0 },
+  { "PROPS", 2 },
+  { "SOFT", 3 },
+  { "STRICT", 5 },
+};
+const ProtobufCEnumDescriptor criu_cg_mode__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "criu_cg_mode",
+  "criu_cg_mode",
+  "CriuCgMode",
+  "",
+  7,
+  criu_cg_mode__enum_values_by_number,
+  7,
+  criu_cg_mode__enum_values_by_name,
+  1,
+  criu_cg_mode__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
+static const ProtobufCEnumValue criu_pre_dump_mode__enum_values_by_number[2] =
+{
+  { "SPLICE", "CRIU_PRE_DUMP_MODE__SPLICE", 1 },
+  { "VM_READ", "CRIU_PRE_DUMP_MODE__VM_READ", 2 },
+};
+static const ProtobufCIntRange criu_pre_dump_mode__value_ranges[] = {
+{1, 0},{0, 2}
+};
+static const ProtobufCEnumValueIndex criu_pre_dump_mode__enum_values_by_name[2] =
+{
+  { "SPLICE", 0 },
+  { "VM_READ", 1 },
+};
+const ProtobufCEnumDescriptor criu_pre_dump_mode__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "criu_pre_dump_mode",
+  "criu_pre_dump_mode",
+  "CriuPreDumpMode",
+  "",
+  2,
+  criu_pre_dump_mode__enum_values_by_number,
+  2,
+  criu_pre_dump_mode__enum_values_by_name,
+  1,
+  criu_pre_dump_mode__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
+static const ProtobufCEnumValue criu_req_type__enum_values_by_number[13] =
+{
+  { "EMPTY", "CRIU_REQ_TYPE__EMPTY", 0 },
+  { "DUMP", "CRIU_REQ_TYPE__DUMP", 1 },
+  { "RESTORE", "CRIU_REQ_TYPE__RESTORE", 2 },
+  { "CHECK", "CRIU_REQ_TYPE__CHECK", 3 },
+  { "PRE_DUMP", "CRIU_REQ_TYPE__PRE_DUMP", 4 },
+  { "PAGE_SERVER", "CRIU_REQ_TYPE__PAGE_SERVER", 5 },
+  { "NOTIFY", "CRIU_REQ_TYPE__NOTIFY", 6 },
+  { "CPUINFO_DUMP", "CRIU_REQ_TYPE__CPUINFO_DUMP", 7 },
+  { "CPUINFO_CHECK", "CRIU_REQ_TYPE__CPUINFO_CHECK", 8 },
+  { "FEATURE_CHECK", "CRIU_REQ_TYPE__FEATURE_CHECK", 9 },
+  { "VERSION", "CRIU_REQ_TYPE__VERSION", 10 },
+  { "WAIT_PID", "CRIU_REQ_TYPE__WAIT_PID", 11 },
+  { "PAGE_SERVER_CHLD", "CRIU_REQ_TYPE__PAGE_SERVER_CHLD", 12 },
+};
+static const ProtobufCIntRange criu_req_type__value_ranges[] = {
+{0, 0},{0, 13}
+};
+static const ProtobufCEnumValueIndex criu_req_type__enum_values_by_name[13] =
+{
+  { "CHECK", 3 },
+  { "CPUINFO_CHECK", 8 },
+  { "CPUINFO_DUMP", 7 },
+  { "DUMP", 1 },
+  { "EMPTY", 0 },
+  { "FEATURE_CHECK", 9 },
+  { "NOTIFY", 6 },
+  { "PAGE_SERVER", 5 },
+  { "PAGE_SERVER_CHLD", 12 },
+  { "PRE_DUMP", 4 },
+  { "RESTORE", 2 },
+  { "VERSION", 10 },
+  { "WAIT_PID", 11 },
+};
+const ProtobufCEnumDescriptor criu_req_type__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "criu_req_type",
+  "criu_req_type",
+  "CriuReqType",
+  "",
+  13,
+  criu_req_type__enum_values_by_number,
+  13,
+  criu_req_type__enum_values_by_name,
+  1,
+  criu_req_type__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
diff --git a/qemu/qemu/linux-user/syscall.c b/qemu/qemu/linux-user/syscall.c
index 04866b4a..07aa14db 100644
--- a/qemu/qemu/linux-user/syscall.c
+++ b/qemu/qemu/linux-user/syscall.c
@@ -47,6 +47,7 @@
 #include <utime.h>
 #include <sys/sysinfo.h>
 #include <sys/signalfd.h>
+#include <stdbool.h>
 //#include <sys/user.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
@@ -112,6 +113,33 @@
 #include "qemu.h"
 #include "fd-trans.h"
 #include <linux/sockios.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <fcntl.h>
+
+#include "criu.h"
+
+#include "tcg/tcg-op.h"
+
+#include "../../patches/afl-qemu-common.h"
+
+// Filedescriptors used by AFL to communicate between forkserver & child
+#define FRKSRV_READ_FD             (198)
+#define FRKSRV_WRITE_FD            (199)
+
+// The next receive after send should create a snapshot
+// Idea is: We're waiting for a return from the other side then
+bool sent = true;
+// If true, we are supposed to write the outputs to a file.
+bool create_outputs = true; //TODO: works? getenv_from_file("FITM_CREATE_OUTPUTS");
+// If true, please do snapshot.
+// we are restored or snapshottet or something.
+bool timewarp_mode = true; //TODO: works? getenv_from_file("LETS_DO_THE_TIMEWARP_AGAIN");
+// every position in this bitstring is interpreted as a fd. pos x == fd x
+// If a position holds a 1 it is a socket
+long long int is_socket = 0;
+
 
 extern unsigned int afl_forksrv_pid;
 
@@ -756,19 +784,11 @@ safe_syscall5(ssize_t, preadv, int, fd, const struct iovec *, iov, int, iovcnt,
               unsigned long, pos_l, unsigned long, pos_h)
 safe_syscall5(ssize_t, pwritev, int, fd, const struct iovec *, iov, int, iovcnt,
               unsigned long, pos_l, unsigned long, pos_h)
-safe_syscall3(int, connect, int, fd, const struct sockaddr *, addr,
-              socklen_t, addrlen)
-safe_syscall6(ssize_t, sendto, int, fd, const void *, buf, size_t, len,
-              int, flags, const struct sockaddr *, addr, socklen_t, addrlen)
-safe_syscall6(ssize_t, recvfrom, int, fd, void *, buf, size_t, len,
-              int, flags, struct sockaddr *, addr, socklen_t *, addrlen)
 safe_syscall3(ssize_t, sendmsg, int, fd, const struct msghdr *, msg, int, flags)
 safe_syscall3(ssize_t, recvmsg, int, fd, struct msghdr *, msg, int, flags)
 safe_syscall2(int, flock, int, fd, int, operation)
 safe_syscall4(int, rt_sigtimedwait, const sigset_t *, these, siginfo_t *, uinfo,
               const struct timespec *, uts, size_t, sigsetsize)
-safe_syscall4(int, accept4, int, fd, struct sockaddr *, addr, socklen_t *, len,
-              int, flags)
 safe_syscall2(int, nanosleep, const struct timespec *, req,
               struct timespec *, rem)
 #ifdef TARGET_NR_clock_nanosleep
@@ -1081,7 +1101,7 @@ static inline rlim_t target_to_host_rlim(abi_ulong target_rlim)
 {
     abi_ulong target_rlim_swap;
     rlim_t result;
-    
+
     target_rlim_swap = tswapal(target_rlim);
     if (target_rlim_swap == TARGET_RLIM_INFINITY)
         return RLIM_INFINITY;
@@ -1089,7 +1109,7 @@ static inline rlim_t target_to_host_rlim(abi_ulong target_rlim)
     result = target_rlim_swap;
     if (target_rlim_swap != (rlim_t)result)
         return RLIM_INFINITY;
-    
+
     return result;
 }
 
@@ -1097,13 +1117,13 @@ static inline abi_ulong host_to_target_rlim(rlim_t rlim)
 {
     abi_ulong target_rlim_swap;
     abi_ulong result;
-    
+
     if (rlim == RLIM_INFINITY || rlim != (abi_long)rlim)
         target_rlim_swap = TARGET_RLIM_INFINITY;
     else
         target_rlim_swap = rlim;
     result = tswapal(target_rlim_swap);
-    
+
     return result;
 }
 
@@ -1482,9 +1502,9 @@ static inline abi_long target_to_host_cmsg(struct msghdr *msgh,
     abi_ulong target_cmsg_addr;
     struct target_cmsghdr *target_cmsg, *target_cmsg_start;
     socklen_t space = 0;
-    
+
     msg_controllen = tswapal(target_msgh->msg_controllen);
-    if (msg_controllen < sizeof (struct target_cmsghdr)) 
+    if (msg_controllen < sizeof (struct target_cmsghdr))
         goto the_end;
     target_cmsg_addr = tswapal(target_msgh->msg_control);
     target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);
@@ -1566,7 +1586,7 @@ static inline abi_long host_to_target_cmsg(struct target_msghdr *target_msgh,
     socklen_t space = 0;
 
     msg_controllen = tswapal(target_msgh->msg_controllen);
-    if (msg_controllen < sizeof (struct target_cmsghdr)) 
+    if (msg_controllen < sizeof (struct target_cmsghdr))
         goto the_end;
     target_cmsg_addr = tswapal(target_msgh->msg_control);
     target_cmsg = lock_user(VERIFY_WRITE, target_cmsg_addr, msg_controllen, 0);
@@ -1792,578 +1812,14 @@ static inline abi_long host_to_target_cmsg(struct target_msghdr *target_msgh,
 static abi_long do_setsockopt(int sockfd, int level, int optname,
                               abi_ulong optval_addr, socklen_t optlen)
 {
-    abi_long ret;
-    int val;
-    struct ip_mreqn *ip_mreq;
-    struct ip_mreq_source *ip_mreq_source;
-
-    switch(level) {
-    case SOL_TCP:
-        /* TCP options all take an 'int' value.  */
-        if (optlen < sizeof(uint32_t))
-            return -TARGET_EINVAL;
-
-        if (get_user_u32(val, optval_addr))
-            return -TARGET_EFAULT;
-        ret = get_errno(setsockopt(sockfd, level, optname, &val, sizeof(val)));
-        break;
-    case SOL_IP:
-        switch(optname) {
-        case IP_TOS:
-        case IP_TTL:
-        case IP_HDRINCL:
-        case IP_ROUTER_ALERT:
-        case IP_RECVOPTS:
-        case IP_RETOPTS:
-        case IP_PKTINFO:
-        case IP_MTU_DISCOVER:
-        case IP_RECVERR:
-        case IP_RECVTTL:
-        case IP_RECVTOS:
-#ifdef IP_FREEBIND
-        case IP_FREEBIND:
-#endif
-        case IP_MULTICAST_TTL:
-        case IP_MULTICAST_LOOP:
-            val = 0;
-            if (optlen >= sizeof(uint32_t)) {
-                if (get_user_u32(val, optval_addr))
-                    return -TARGET_EFAULT;
-            } else if (optlen >= 1) {
-                if (get_user_u8(val, optval_addr))
-                    return -TARGET_EFAULT;
-            }
-            ret = get_errno(setsockopt(sockfd, level, optname, &val, sizeof(val)));
-            break;
-        case IP_ADD_MEMBERSHIP:
-        case IP_DROP_MEMBERSHIP:
-            if (optlen < sizeof (struct target_ip_mreq) ||
-                optlen > sizeof (struct target_ip_mreqn))
-                return -TARGET_EINVAL;
-
-            ip_mreq = (struct ip_mreqn *) alloca(optlen);
-            target_to_host_ip_mreq(ip_mreq, optval_addr, optlen);
-            ret = get_errno(setsockopt(sockfd, level, optname, ip_mreq, optlen));
-            break;
-
-        case IP_BLOCK_SOURCE:
-        case IP_UNBLOCK_SOURCE:
-        case IP_ADD_SOURCE_MEMBERSHIP:
-        case IP_DROP_SOURCE_MEMBERSHIP:
-            if (optlen != sizeof (struct target_ip_mreq_source))
-                return -TARGET_EINVAL;
-
-            ip_mreq_source = lock_user(VERIFY_READ, optval_addr, optlen, 1);
-            ret = get_errno(setsockopt(sockfd, level, optname, ip_mreq_source, optlen));
-            unlock_user (ip_mreq_source, optval_addr, 0);
-            break;
-
-        default:
-            goto unimplemented;
-        }
-        break;
-    case SOL_IPV6:
-        switch (optname) {
-        case IPV6_MTU_DISCOVER:
-        case IPV6_MTU:
-        case IPV6_V6ONLY:
-        case IPV6_RECVPKTINFO:
-        case IPV6_UNICAST_HOPS:
-        case IPV6_MULTICAST_HOPS:
-        case IPV6_MULTICAST_LOOP:
-        case IPV6_RECVERR:
-        case IPV6_RECVHOPLIMIT:
-        case IPV6_2292HOPLIMIT:
-        case IPV6_CHECKSUM:
-            val = 0;
-            if (optlen < sizeof(uint32_t)) {
-                return -TARGET_EINVAL;
-            }
-            if (get_user_u32(val, optval_addr)) {
-                return -TARGET_EFAULT;
-            }
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &val, sizeof(val)));
-            break;
-        case IPV6_PKTINFO:
-        {
-            struct in6_pktinfo pki;
-
-            if (optlen < sizeof(pki)) {
-                return -TARGET_EINVAL;
-            }
-
-            if (copy_from_user(&pki, optval_addr, sizeof(pki))) {
-                return -TARGET_EFAULT;
-            }
-
-            pki.ipi6_ifindex = tswap32(pki.ipi6_ifindex);
-
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &pki, sizeof(pki)));
-            break;
-        }
-        default:
-            goto unimplemented;
-        }
-        break;
-    case SOL_ICMPV6:
-        switch (optname) {
-        case ICMPV6_FILTER:
-        {
-            struct icmp6_filter icmp6f;
-
-            if (optlen > sizeof(icmp6f)) {
-                optlen = sizeof(icmp6f);
-            }
-
-            if (copy_from_user(&icmp6f, optval_addr, optlen)) {
-                return -TARGET_EFAULT;
-            }
-
-            for (val = 0; val < 8; val++) {
-                icmp6f.data[val] = tswap32(icmp6f.data[val]);
-            }
-
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &icmp6f, optlen));
-            break;
-        }
-        default:
-            goto unimplemented;
-        }
-        break;
-    case SOL_RAW:
-        switch (optname) {
-        case ICMP_FILTER:
-        case IPV6_CHECKSUM:
-            /* those take an u32 value */
-            if (optlen < sizeof(uint32_t)) {
-                return -TARGET_EINVAL;
-            }
-
-            if (get_user_u32(val, optval_addr)) {
-                return -TARGET_EFAULT;
-            }
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &val, sizeof(val)));
-            break;
-
-        default:
-            goto unimplemented;
-        }
-        break;
-    case TARGET_SOL_SOCKET:
-        switch (optname) {
-        case TARGET_SO_RCVTIMEO:
-        {
-                struct timeval tv;
-
-                optname = SO_RCVTIMEO;
-
-set_timeout:
-                if (optlen != sizeof(struct target_timeval)) {
-                    return -TARGET_EINVAL;
-                }
-
-                if (copy_from_user_timeval(&tv, optval_addr)) {
-                    return -TARGET_EFAULT;
-                }
-
-                ret = get_errno(setsockopt(sockfd, SOL_SOCKET, optname,
-                                &tv, sizeof(tv)));
-                return ret;
-        }
-        case TARGET_SO_SNDTIMEO:
-                optname = SO_SNDTIMEO;
-                goto set_timeout;
-        case TARGET_SO_ATTACH_FILTER:
-        {
-                struct target_sock_fprog *tfprog;
-                struct target_sock_filter *tfilter;
-                struct sock_fprog fprog;
-                struct sock_filter *filter;
-                int i;
-
-                if (optlen != sizeof(*tfprog)) {
-                    return -TARGET_EINVAL;
-                }
-                if (!lock_user_struct(VERIFY_READ, tfprog, optval_addr, 0)) {
-                    return -TARGET_EFAULT;
-                }
-                if (!lock_user_struct(VERIFY_READ, tfilter,
-                                      tswapal(tfprog->filter), 0)) {
-                    unlock_user_struct(tfprog, optval_addr, 1);
-                    return -TARGET_EFAULT;
-                }
-
-                fprog.len = tswap16(tfprog->len);
-                filter = g_try_new(struct sock_filter, fprog.len);
-                if (filter == NULL) {
-                    unlock_user_struct(tfilter, tfprog->filter, 1);
-                    unlock_user_struct(tfprog, optval_addr, 1);
-                    return -TARGET_ENOMEM;
-                }
-                for (i = 0; i < fprog.len; i++) {
-                    filter[i].code = tswap16(tfilter[i].code);
-                    filter[i].jt = tfilter[i].jt;
-                    filter[i].jf = tfilter[i].jf;
-                    filter[i].k = tswap32(tfilter[i].k);
-                }
-                fprog.filter = filter;
-
-                ret = get_errno(setsockopt(sockfd, SOL_SOCKET,
-                                SO_ATTACH_FILTER, &fprog, sizeof(fprog)));
-                g_free(filter);
-
-                unlock_user_struct(tfilter, tfprog->filter, 1);
-                unlock_user_struct(tfprog, optval_addr, 1);
-                return ret;
-        }
-	case TARGET_SO_BINDTODEVICE:
-	{
-		char *dev_ifname, *addr_ifname;
-
-		if (optlen > IFNAMSIZ - 1) {
-		    optlen = IFNAMSIZ - 1;
-		}
-		dev_ifname = lock_user(VERIFY_READ, optval_addr, optlen, 1);
-		if (!dev_ifname) {
-		    return -TARGET_EFAULT;
-		}
-		optname = SO_BINDTODEVICE;
-		addr_ifname = alloca(IFNAMSIZ);
-		memcpy(addr_ifname, dev_ifname, optlen);
-		addr_ifname[optlen] = 0;
-		ret = get_errno(setsockopt(sockfd, SOL_SOCKET, optname,
-                                           addr_ifname, optlen));
-		unlock_user (dev_ifname, optval_addr, 0);
-		return ret;
-	}
-        case TARGET_SO_LINGER:
-        {
-                struct linger lg;
-                struct target_linger *tlg;
-
-                if (optlen != sizeof(struct target_linger)) {
-                    return -TARGET_EINVAL;
-                }
-                if (!lock_user_struct(VERIFY_READ, tlg, optval_addr, 1)) {
-                    return -TARGET_EFAULT;
-                }
-                __get_user(lg.l_onoff, &tlg->l_onoff);
-                __get_user(lg.l_linger, &tlg->l_linger);
-                ret = get_errno(setsockopt(sockfd, SOL_SOCKET, SO_LINGER,
-                                &lg, sizeof(lg)));
-                unlock_user_struct(tlg, optval_addr, 0);
-                return ret;
-        }
-            /* Options with 'int' argument.  */
-        case TARGET_SO_DEBUG:
-		optname = SO_DEBUG;
-		break;
-        case TARGET_SO_REUSEADDR:
-		optname = SO_REUSEADDR;
-		break;
-#ifdef SO_REUSEPORT
-        case TARGET_SO_REUSEPORT:
-                optname = SO_REUSEPORT;
-                break;
-#endif
-        case TARGET_SO_TYPE:
-		optname = SO_TYPE;
-		break;
-        case TARGET_SO_ERROR:
-		optname = SO_ERROR;
-		break;
-        case TARGET_SO_DONTROUTE:
-		optname = SO_DONTROUTE;
-		break;
-        case TARGET_SO_BROADCAST:
-		optname = SO_BROADCAST;
-		break;
-        case TARGET_SO_SNDBUF:
-		optname = SO_SNDBUF;
-		break;
-        case TARGET_SO_SNDBUFFORCE:
-                optname = SO_SNDBUFFORCE;
-                break;
-        case TARGET_SO_RCVBUF:
-		optname = SO_RCVBUF;
-		break;
-        case TARGET_SO_RCVBUFFORCE:
-                optname = SO_RCVBUFFORCE;
-                break;
-        case TARGET_SO_KEEPALIVE:
-		optname = SO_KEEPALIVE;
-		break;
-        case TARGET_SO_OOBINLINE:
-		optname = SO_OOBINLINE;
-		break;
-        case TARGET_SO_NO_CHECK:
-		optname = SO_NO_CHECK;
-		break;
-        case TARGET_SO_PRIORITY:
-		optname = SO_PRIORITY;
-		break;
-#ifdef SO_BSDCOMPAT
-        case TARGET_SO_BSDCOMPAT:
-		optname = SO_BSDCOMPAT;
-		break;
-#endif
-        case TARGET_SO_PASSCRED:
-		optname = SO_PASSCRED;
-		break;
-        case TARGET_SO_PASSSEC:
-                optname = SO_PASSSEC;
-                break;
-        case TARGET_SO_TIMESTAMP:
-		optname = SO_TIMESTAMP;
-		break;
-        case TARGET_SO_RCVLOWAT:
-		optname = SO_RCVLOWAT;
-		break;
-        default:
-            goto unimplemented;
-        }
-	if (optlen < sizeof(uint32_t))
-            return -TARGET_EINVAL;
-
-	if (get_user_u32(val, optval_addr))
-            return -TARGET_EFAULT;
-	ret = get_errno(setsockopt(sockfd, SOL_SOCKET, optname, &val, sizeof(val)));
-        break;
-    default:
-    unimplemented:
-        gemu_log("Unsupported setsockopt level=%d optname=%d\n", level, optname);
-        ret = -TARGET_ENOPROTOOPT;
-    }
-    return ret;
+    return 0;
 }
 
 /* do_getsockopt() Must return target values and target errnos. */
 static abi_long do_getsockopt(int sockfd, int level, int optname,
                               abi_ulong optval_addr, abi_ulong optlen)
 {
-    abi_long ret;
-    int len, val;
-    socklen_t lv;
-
-    switch(level) {
-    case TARGET_SOL_SOCKET:
-        level = SOL_SOCKET;
-        switch (optname) {
-        /* These don't just return a single integer */
-        case TARGET_SO_RCVTIMEO:
-        case TARGET_SO_SNDTIMEO:
-        case TARGET_SO_PEERNAME:
-            goto unimplemented;
-        case TARGET_SO_PEERCRED: {
-            struct ucred cr;
-            socklen_t crlen;
-            struct target_ucred *tcr;
-
-            if (get_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            if (len < 0) {
-                return -TARGET_EINVAL;
-            }
-
-            crlen = sizeof(cr);
-            ret = get_errno(getsockopt(sockfd, level, SO_PEERCRED,
-                                       &cr, &crlen));
-            if (ret < 0) {
-                return ret;
-            }
-            if (len > crlen) {
-                len = crlen;
-            }
-            if (!lock_user_struct(VERIFY_WRITE, tcr, optval_addr, 0)) {
-                return -TARGET_EFAULT;
-            }
-            __put_user(cr.pid, &tcr->pid);
-            __put_user(cr.uid, &tcr->uid);
-            __put_user(cr.gid, &tcr->gid);
-            unlock_user_struct(tcr, optval_addr, 1);
-            if (put_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            break;
-        }
-        case TARGET_SO_LINGER:
-        {
-            struct linger lg;
-            socklen_t lglen;
-            struct target_linger *tlg;
-
-            if (get_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            if (len < 0) {
-                return -TARGET_EINVAL;
-            }
-
-            lglen = sizeof(lg);
-            ret = get_errno(getsockopt(sockfd, level, SO_LINGER,
-                                       &lg, &lglen));
-            if (ret < 0) {
-                return ret;
-            }
-            if (len > lglen) {
-                len = lglen;
-            }
-            if (!lock_user_struct(VERIFY_WRITE, tlg, optval_addr, 0)) {
-                return -TARGET_EFAULT;
-            }
-            __put_user(lg.l_onoff, &tlg->l_onoff);
-            __put_user(lg.l_linger, &tlg->l_linger);
-            unlock_user_struct(tlg, optval_addr, 1);
-            if (put_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            break;
-        }
-        /* Options with 'int' argument.  */
-        case TARGET_SO_DEBUG:
-            optname = SO_DEBUG;
-            goto int_case;
-        case TARGET_SO_REUSEADDR:
-            optname = SO_REUSEADDR;
-            goto int_case;
-#ifdef SO_REUSEPORT
-        case TARGET_SO_REUSEPORT:
-            optname = SO_REUSEPORT;
-            goto int_case;
-#endif
-        case TARGET_SO_TYPE:
-            optname = SO_TYPE;
-            goto int_case;
-        case TARGET_SO_ERROR:
-            optname = SO_ERROR;
-            goto int_case;
-        case TARGET_SO_DONTROUTE:
-            optname = SO_DONTROUTE;
-            goto int_case;
-        case TARGET_SO_BROADCAST:
-            optname = SO_BROADCAST;
-            goto int_case;
-        case TARGET_SO_SNDBUF:
-            optname = SO_SNDBUF;
-            goto int_case;
-        case TARGET_SO_RCVBUF:
-            optname = SO_RCVBUF;
-            goto int_case;
-        case TARGET_SO_KEEPALIVE:
-            optname = SO_KEEPALIVE;
-            goto int_case;
-        case TARGET_SO_OOBINLINE:
-            optname = SO_OOBINLINE;
-            goto int_case;
-        case TARGET_SO_NO_CHECK:
-            optname = SO_NO_CHECK;
-            goto int_case;
-        case TARGET_SO_PRIORITY:
-            optname = SO_PRIORITY;
-            goto int_case;
-#ifdef SO_BSDCOMPAT
-        case TARGET_SO_BSDCOMPAT:
-            optname = SO_BSDCOMPAT;
-            goto int_case;
-#endif
-        case TARGET_SO_PASSCRED:
-            optname = SO_PASSCRED;
-            goto int_case;
-        case TARGET_SO_TIMESTAMP:
-            optname = SO_TIMESTAMP;
-            goto int_case;
-        case TARGET_SO_RCVLOWAT:
-            optname = SO_RCVLOWAT;
-            goto int_case;
-        case TARGET_SO_ACCEPTCONN:
-            optname = SO_ACCEPTCONN;
-            goto int_case;
-        default:
-            goto int_case;
-        }
-        break;
-    case SOL_TCP:
-        /* TCP options all take an 'int' value.  */
-    int_case:
-        if (get_user_u32(len, optlen))
-            return -TARGET_EFAULT;
-        if (len < 0)
-            return -TARGET_EINVAL;
-        lv = sizeof(lv);
-        ret = get_errno(getsockopt(sockfd, level, optname, &val, &lv));
-        if (ret < 0)
-            return ret;
-        if (optname == SO_TYPE) {
-            val = host_to_target_sock_type(val);
-        }
-        if (len > lv)
-            len = lv;
-        if (len == 4) {
-            if (put_user_u32(val, optval_addr))
-                return -TARGET_EFAULT;
-        } else {
-            if (put_user_u8(val, optval_addr))
-                return -TARGET_EFAULT;
-        }
-        if (put_user_u32(len, optlen))
-            return -TARGET_EFAULT;
-        break;
-    case SOL_IP:
-        switch(optname) {
-        case IP_TOS:
-        case IP_TTL:
-        case IP_HDRINCL:
-        case IP_ROUTER_ALERT:
-        case IP_RECVOPTS:
-        case IP_RETOPTS:
-        case IP_PKTINFO:
-        case IP_MTU_DISCOVER:
-        case IP_RECVERR:
-        case IP_RECVTOS:
-#ifdef IP_FREEBIND
-        case IP_FREEBIND:
-#endif
-        case IP_MULTICAST_TTL:
-        case IP_MULTICAST_LOOP:
-            if (get_user_u32(len, optlen))
-                return -TARGET_EFAULT;
-            if (len < 0)
-                return -TARGET_EINVAL;
-            lv = sizeof(lv);
-            ret = get_errno(getsockopt(sockfd, level, optname, &val, &lv));
-            if (ret < 0)
-                return ret;
-            if (len < sizeof(int) && len > 0 && val >= 0 && val < 255) {
-                len = 1;
-                if (put_user_u32(len, optlen)
-                    || put_user_u8(val, optval_addr))
-                    return -TARGET_EFAULT;
-            } else {
-                if (len > sizeof(int))
-                    len = sizeof(int);
-                if (put_user_u32(len, optlen)
-                    || put_user_u32(val, optval_addr))
-                    return -TARGET_EFAULT;
-            }
-            break;
-        default:
-            ret = -TARGET_ENOPROTOOPT;
-            break;
-        }
-        break;
-    default:
-    unimplemented:
-        gemu_log("getsockopt level=%d optname=%d not yet supported\n",
-                 level, optname);
-        ret = -TARGET_EOPNOTSUPP;
-        break;
-    }
-    return ret;
+    return 0;
 }
 
 /* Convert target low/high pair representing file offset into the host
@@ -2528,113 +1984,36 @@ static inline int target_to_host_sock_type(int *type)
     return 0;
 }
 
-/* Try to emulate socket type flags after socket creation.  */
-static int sock_flags_fixup(int fd, int target_type)
-{
-#if !defined(SOCK_NONBLOCK) && defined(O_NONBLOCK)
-    if (target_type & TARGET_SOCK_NONBLOCK) {
-        int flags = fcntl(fd, F_GETFL);
-        if (fcntl(fd, F_SETFL, O_NONBLOCK | flags) == -1) {
-            close(fd);
-            return -TARGET_EINVAL;
-        }
-    }
-#endif
-    return fd;
-}
-
 /* do_socket() Must return target values and target errnos. */
 static abi_long do_socket(int domain, int type, int protocol)
 {
-    int target_type = type;
-    int ret;
-
-    ret = target_to_host_sock_type(&type);
-    if (ret) {
-        return ret;
-    }
+    char *uuid = get_new_uuid();
+    char path[44] = "./fd/";
+    strncat(path, uuid, 37);
 
-    if (domain == PF_NETLINK && !(
-#ifdef CONFIG_RTNETLINK
-         protocol == NETLINK_ROUTE ||
-#endif
-         protocol == NETLINK_KOBJECT_UEVENT ||
-         protocol == NETLINK_AUDIT)) {
-        return -EPFNOSUPPORT;
-    }
-
-    if (domain == AF_PACKET ||
-        (domain == AF_INET && type == SOCK_PACKET)) {
-        protocol = tswap16(protocol);
-    }
+    int new_fd = open(path, O_RDWR | O_CREAT, 0666);
+    chmod(path, 0666);
+    is_socket |= 1 << new_fd;
 
-    ret = get_errno(socket(domain, type, protocol));
-    if (ret >= 0) {
-        ret = sock_flags_fixup(ret, target_type);
-        if (type == SOCK_PACKET) {
-            /* Manage an obsolete case :
-             * if socket type is SOCK_PACKET, bind by name
-             */
-            fd_trans_register(ret, &target_packet_trans);
-        } else if (domain == PF_NETLINK) {
-            switch (protocol) {
-#ifdef CONFIG_RTNETLINK
-            case NETLINK_ROUTE:
-                fd_trans_register(ret, &target_netlink_route_trans);
-                break;
-#endif
-            case NETLINK_KOBJECT_UEVENT:
-                /* nothing to do: messages are strings */
-                break;
-            case NETLINK_AUDIT:
-                fd_trans_register(ret, &target_netlink_audit_trans);
-                break;
-            default:
-                g_assert_not_reached();
-            }
-        }
-    }
-    return ret;
+    return new_fd;
 }
 
 /* do_bind() Must return target values and target errnos. */
 static abi_long do_bind(int sockfd, abi_ulong target_addr,
                         socklen_t addrlen)
 {
-    void *addr;
-    abi_long ret;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    addr = alloca(addrlen+1);
-
-    ret = target_to_host_sockaddr(sockfd, addr, target_addr, addrlen);
-    if (ret)
-        return ret;
-
-    return get_errno(bind(sockfd, addr, addrlen));
+    // Adress binding always works as we are only writing to a file
+    // check: https://github.com/zardus/preeny/blob/master/src/desock.c#L259
+    return 0;
 }
 
 /* do_connect() Must return target values and target errnos. */
 static abi_long do_connect(int sockfd, abi_ulong target_addr,
                            socklen_t addrlen)
 {
-    void *addr;
-    abi_long ret;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    addr = alloca(addrlen+1);
-
-    ret = target_to_host_sockaddr(sockfd, addr, target_addr, addrlen);
-    if (ret)
-        return ret;
-
-    return get_errno(safe_connect(sockfd, addr, addrlen));
+    // Connecting to a remote adr. always works as we are only running locally
+    // Check: https://github.com/zardus/preeny/blob/master/src/desock.c#L275
+    return 0;
 }
 
 /* do_sendrecvmsg_locked() Must return target values and target errnos. */
@@ -2811,37 +2190,15 @@ static abi_long do_sendrecvmmsg(int fd, abi_ulong target_msgvec,
 static abi_long do_accept4(int fd, abi_ulong target_addr,
                            abi_ulong target_addrlen_addr, int flags)
 {
-    socklen_t addrlen;
-    void *addr;
-    abi_long ret;
-    int host_flags;
-
-    host_flags = target_to_host_bitmask(flags, fcntl_flags_tbl);
-
-    if (target_addr == 0) {
-        return get_errno(safe_accept4(fd, NULL, NULL, host_flags));
-    }
+    char *uuid = get_new_uuid();
+    char path[44] = "./fd/";
+    strncat(path, uuid, 37);
 
-    /* linux returns EINVAL if addrlen pointer is invalid */
-    if (get_user_u32(addrlen, target_addrlen_addr))
-        return -TARGET_EINVAL;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    if (!access_ok(VERIFY_WRITE, target_addr, addrlen))
-        return -TARGET_EINVAL;
-
-    addr = alloca(addrlen);
+    int new_fd = open(path, O_RDWR | O_CREAT, 0666);
+    chmod(path, 0666);
+    is_socket |= 1 << new_fd;
 
-    ret = get_errno(safe_accept4(fd, addr, &addrlen, host_flags));
-    if (!is_error(ret)) {
-        host_to_target_sockaddr(target_addr, addr, addrlen);
-        if (put_user_u32(addrlen, target_addrlen_addr))
-            ret = -TARGET_EFAULT;
-    }
-    return ret;
+    return new_fd;
 }
 
 /* do_getpeername() Must return target values and target errnos. */
@@ -2924,102 +2281,113 @@ static abi_long do_socketpair(int domain, int type, int protocol,
 static abi_long do_sendto(int fd, abi_ulong msg, size_t len, int flags,
                           abi_ulong target_addr, socklen_t addrlen)
 {
-    void *addr;
-    void *host_msg;
-    void *copy_msg = NULL;
-    abi_long ret;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    host_msg = lock_user(VERIFY_READ, msg, len, 1);
-    if (!host_msg)
-        return -TARGET_EFAULT;
-    if (fd_trans_target_to_host_data(fd)) {
-        copy_msg = host_msg;
-        host_msg = g_malloc(len);
-        memcpy(host_msg, copy_msg, len);
-        ret = fd_trans_target_to_host_data(fd)(host_msg, len);
-        if (ret < 0) {
-            goto fail;
-        }
-    }
-    if (target_addr) {
-        addr = alloca(addrlen+1);
-        ret = target_to_host_sockaddr(fd, addr, target_addr, addrlen);
-        if (ret) {
-            goto fail;
-        }
-        ret = get_errno(safe_sendto(fd, host_msg, len, flags, addr, addrlen));
+    sent = true;
+    // Only write sth to the fd if we are in consolidation
+    if(!create_outputs) {
+        return (ssize_t)len;
     } else {
-        ret = get_errno(safe_sendto(fd, host_msg, len, flags, NULL, 0));
-    }
-fail:
-    if (copy_msg) {
-        g_free(host_msg);
-        host_msg = copy_msg;
+        FILE *fp;
+        char *uuid = get_new_uuid();
+        char path[49] = "/tmp/fitm-";
+        strncat(path, uuid, 37);
+        fp = fopen(path, "w+");
+        fprintf(fp, "fd: %d\nmsg: %s\nlen: %ld", fd, (char *)msg, len);
+        fclose(fp);
+
+        _ = system("ls -la /proc/self/fd > /tmp/fitm-sendto");
+        return write(fd, (char *) msg, len);
     }
-    unlock_user(host_msg, msg, 0);
-    return ret;
 }
 
 /* do_recvfrom() Must return target values and target errnos. */
-static abi_long do_recvfrom(int fd, abi_ulong msg, size_t len, int flags,
+static abi_long do_recvfrom(CPUState *cpu, int fd, abi_ulong msg, size_t len, int flags,
                             abi_ulong target_addr,
                             abi_ulong target_addrlen)
 {
-    socklen_t addrlen;
-    void *addr;
-    void *host_msg;
-    abi_long ret;
 
-    host_msg = lock_user(VERIFY_WRITE, msg, len, 0);
-    if (!host_msg)
-        return -TARGET_EFAULT;
-    if (target_addr) {
-        if (get_user_u32(addrlen, target_addrlen)) {
-            ret = -TARGET_EFAULT;
-            goto fail;
+    if(sent){
+        if (!timewarp_mode) {
+            exit(0);
+        }
+        sent = false; // After restore, we'll await the next sent before criuin' again
+
+        if (fcntl(FRKSRV_READ_FD, F_GETFD) == -1) {
+            int read_pipe[2];
+            int write_pipe[2];
+            if (pipe(read_pipe) == -1) {
+                printf("QEMU: Could not open AFL Forkserver read pipe!");
+            }
+            if (pipe(write_pipe) == -1) {
+                printf("QEMU: Could not open AFL Forkserver read pipe!");
+            }
+            dup2(read_pipe[0], FRKSRV_READ_FD);
+            dup2(write_pipe[1], FRKSRV_WRITE_FD);
+            close(read_pipe[0]);
+            close(read_pipe[1]);
+            close(write_pipe[0]);
+            close(write_pipe[1]);
+        }
+
+        FILE *f = fopen("./pipes", "w");
+        char *buff = calloc(200, 1);
+        _ = readlink("/proc/self/fd/198", buff, 100);
+        char *tmp = (&buff[strlen(buff)])+1;
+        buff[strlen(buff)] = '\n';
+        _ = readlink("/proc/self/fd/199", tmp, 100);
+        fprintf(f, "%s\n", buff);
+        free(buff);
+        fclose(f);
+
+        // untested, may need debugging
+        close(0);
+        do_criu();
+        // Weird bug making criu restore crash - this solves it
+        sleep(0.2);
+
+	create_outputs = getenv_from_file("FITM_CREATE_OUTPUTS");
+	timewarp_mode = getenv_from_file("LETS_DO_THE_TIMEWARP_AGAIN");
+
+        if (!timewarp_mode) {
+            char* shm_env_var = getenv_from_file(SHM_ENV_VAR);
+            char* afl_inst_ratio = getenv_from_file("AFL_INST_RATIO");
+            if(shm_env_var){
+                afl_setup(shm_env_var, afl_inst_ratio);
+                afl_forkserver(cpu);
+            } else {
+                puts("Forkserver not started, since SHM_ENV_VAR env variable is missing");
+            }
         }
-        if ((int)addrlen < 0) {
-            ret = -TARGET_EINVAL;
-            goto fail;
+
+        // We want to get input from files so we pipe the file we get from AFL through an environment var into here.
+        // The file is used as stdin
+        char* input = getenv_from_file("INPUT_FILENAME");
+        FILE* input_file = fopen(input, "r");
+
+        if(!input_file){
+            printf("fatal: could not fopen INPUT_FILENAME: %s\n", input);
+            exit(1);
         }
-        addr = alloca(addrlen);
-        ret = get_errno(safe_recvfrom(fd, host_msg, len, flags,
-                                      addr, &addrlen));
-    } else {
-        addr = NULL; /* To keep compiler quiet.  */
-        ret = get_errno(safe_recvfrom(fd, host_msg, len, flags, NULL, 0));
-    }
-    if (!is_error(ret)) {
-        if (fd_trans_host_to_target_data(fd)) {
-            abi_long trans;
-            trans = fd_trans_host_to_target_data(fd)(host_msg, MIN(ret, len));
-            if (is_error(trans)) {
-                ret = trans;
-                goto fail;
-            }
+
+        int input_fd = fileno(input_file);
+        if(input_fd == -1){
+            printf("fatal: could not: %s\n", input);
+            perror("fatal: could not fileno INPUT_FILENAME");
+            exit(1);
         }
-        if (target_addr) {
-            host_to_target_sockaddr(target_addr, addr, addrlen);
-            if (put_user_u32(addrlen, target_addrlen)) {
-                ret = -TARGET_EFAULT;
-                goto fail;
-            }
+        // An open may result in INPUT_FILENAME at fd 0 if 0 is not used before calling fopen
+        if(input_fd){
+            dup2(input_fd, 0);
+            close(input_fd);
         }
-        unlock_user(host_msg, msg, len);
-    } else {
-fail:
-        unlock_user(host_msg, msg, 0);
     }
-    return ret;
+    // read did not read anything without setting FD to the beginning of the file.
+//    lseek(0, 0, SEEK_SET);
+    return read(0, (char *)msg, len);
 }
 
 #ifdef TARGET_NR_socketcall
 /* do_socketcall() must return target values and target errnos. */
-static abi_long do_socketcall(int num, abi_ulong vptr)
+static abi_long do_socketcall(CPUState *cpu, int num, abi_ulong vptr)
 {
     static const unsigned nargs[] = { /* number of arguments per operation */
         [TARGET_SYS_SOCKET] = 3,      /* domain, type, protocol */
@@ -3070,7 +2438,7 @@ static abi_long do_socketcall(int num, abi_ulong vptr)
     case TARGET_SYS_CONNECT: /* sockfd, addr, addrlen */
         return do_connect(a[0], a[1], a[2]);
     case TARGET_SYS_LISTEN: /* sockfd, backlog */
-        return get_errno(listen(a[0], a[1]));
+        return 0;
     case TARGET_SYS_ACCEPT: /* sockfd, addr, addrlen */
         return do_accept4(a[0], a[1], a[2], 0);
     case TARGET_SYS_GETSOCKNAME: /* sockfd, addr, addrlen */
@@ -3082,12 +2450,13 @@ static abi_long do_socketcall(int num, abi_ulong vptr)
     case TARGET_SYS_SEND: /* sockfd, msg, len, flags */
         return do_sendto(a[0], a[1], a[2], a[3], 0, 0);
     case TARGET_SYS_RECV: /* sockfd, msg, len, flags */
-        return do_recvfrom(a[0], a[1], a[2], a[3], 0, 0);
+        return do_recvfrom(cpu, a[0], a[1], a[2], a[3], 0, 0);
     case TARGET_SYS_SENDTO: /* sockfd, msg, len, flags, addr, addrlen */
         return do_sendto(a[0], a[1], a[2], a[3], a[4], a[5]);
     case TARGET_SYS_RECVFROM: /* sockfd, msg, len, flags, addr, addrlen */
-        return do_recvfrom(a[0], a[1], a[2], a[3], a[4], a[5]);
+        return do_recvfrom(cpu, a[0], a[1], a[2], a[3], a[4], a[5]);
     case TARGET_SYS_SHUTDOWN: /* sockfd, how */
+        is_socket &= ~(long long int)(1 << arg1);
         return get_errno(shutdown(a[0], a[1]));
     case TARGET_SYS_SETSOCKOPT: /* sockfd, level, optname, optval, optlen */
         return do_setsockopt(a[0], a[1], a[2], a[3], a[4]);
@@ -5218,7 +4587,7 @@ abi_long do_set_thread_area(CPUX86State *env, abi_ulong ptr)
     }
     unlock_user_struct(target_ldt_info, ptr, 1);
 
-    if (ldt_info.entry_number < TARGET_GDT_ENTRY_TLS_MIN || 
+    if (ldt_info.entry_number < TARGET_GDT_ENTRY_TLS_MIN ||
         ldt_info.entry_number > TARGET_GDT_ENTRY_TLS_MAX)
            return -TARGET_EINVAL;
     seg_32bit = ldt_info.flags & 1;
@@ -5296,7 +4665,7 @@ static abi_long do_get_thread_area(CPUX86State *env, abi_ulong ptr)
     lp = (uint32_t *)(gdt_table + idx);
     entry_1 = tswap32(lp[0]);
     entry_2 = tswap32(lp[1]);
-    
+
     read_exec_only = ((entry_2 >> 9) & 1) ^ 1;
     contents = (entry_2 >> 10) & 3;
     seg_not_present = ((entry_2 >> 15) & 1) ^ 1;
@@ -5312,8 +4681,8 @@ static abi_long do_get_thread_area(CPUX86State *env, abi_ulong ptr)
         (read_exec_only << 3) | (limit_in_pages << 4) |
         (seg_not_present << 5) | (useable << 6) | (lm << 7);
     limit = (entry_1 & 0xffff) | (entry_2  & 0xf0000);
-    base_addr = (entry_1 >> 16) | 
-        (entry_2 & 0xff000000) | 
+    base_addr = (entry_1 >> 16) |
+        (entry_2 & 0xff000000) |
         ((entry_2 & 0xff) << 16);
     target_ldt_info->base_addr = tswapal(base_addr);
     target_ldt_info->limit = tswap32(limit);
@@ -6778,7 +6147,7 @@ static int do_openat(void *cpu_env, int dirfd, const char *pathname, int flags,
         int fd, r;
 
         /* create temporary file to map stat to */
-        tmpdir = getenv("TMPDIR");
+        tmpdir = getenv_from_file("TMPDIR");
         if (!tmpdir)
             tmpdir = "/tmp";
         snprintf(filename, sizeof(filename), "%s/qemu-open.XXXXXX", tmpdir);
@@ -6912,7 +6281,6 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
     struct statfs stfs;
 #endif
     void *p;
-
     switch(num) {
     case TARGET_NR_exit:
         /* In old applications this may be used to implement _exit(2).
@@ -6952,9 +6320,80 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
         _exit(arg1);
         return 0; /* avoid warning */
     case TARGET_NR_read:
-        if (arg3 == 0) {
-            return 0;
-        } else {
+            if (arg3 == 0) {
+                return 0;
+            } else {
+            if(sent && (is_socket >> arg1) & 1){
+                if (!timewarp_mode) {
+                    exit(0);
+                }
+                sent = false; // After restore, we'll await the next sent before criuin' again
+                if (fcntl(FRKSRV_READ_FD, F_GETFD) == -1) {
+                    int read_pipe[2];
+                    int write_pipe[2];
+                    if (pipe(read_pipe) == -1) {
+                        printf("QEMU: Could not open AFL Forkserver read pipe!");
+                    }
+                    if (pipe(write_pipe) == -1) {
+                        printf("QEMU: Could not open AFL Forkserver read pipe!");
+                    }
+                    dup2(read_pipe[0], FRKSRV_READ_FD);
+                    dup2(write_pipe[1], FRKSRV_WRITE_FD);
+                    close(read_pipe[0]);
+                    close(read_pipe[1]);
+                    close(write_pipe[0]);
+                    close(write_pipe[1]);
+                }
+                FILE *f = fopen("./pipes", "w");
+                char *buff = calloc(200, 1);
+                _ = readlink("/proc/self/fd/198", buff, 100);
+                char *tmp = (&buff[strlen(buff)])+1;
+                buff[strlen(buff)] = '\n';
+                _ = readlink("/proc/self/fd/199", tmp, 100);
+                fprintf(f, "%s\n", buff);
+                free(buff);
+                fclose(f);
+
+                // untested, may need debugging
+                close(0);
+                do_criu();
+                // Weird bug making criu restore crash - this solves it
+                sleep(0.2);
+                system("touch /tmp/after_docriu");
+		create_outputs = getenv_from_file("FITM_CREATE_OUTPUTS");
+		timewarp_mode = getenv_from_file("LETS_DO_THE_TIMEWARP_AGAIN");
+
+                if (timewarp_mode) {
+                    exit(0);
+		}
+                if (!timewarp_mode) {
+                    char* shm_env_var = getenv_from_file(SHM_ENV_VAR);
+                    char* afl_inst_ratio = getenv_from_file("AFL_INST_RATIO");
+                    if(shm_env_var){
+                        afl_setup(shm_env_var, afl_inst_ratio);
+                        afl_forkserver(cpu);
+                    } else {
+                        puts("Forkserver not started, since SHM_ENV_VAR env variable is missing");
+                    }
+                }
+
+                // We want to get input from files so we pipe the file we get from AFL through an environment var into here.
+                // The file is used as stdin
+                char* input = getenv_from_file("INPUT_FILENAME");
+                FILE* input_file = fopen(input, "r");
+                if(!input_file){
+                    printf("fatal: could not fopen INPUT_FILENAME: %s\n", input);
+                    exit(1);
+                }
+                int input_fd = fileno(input_file);
+                if(!input_fd){
+                    printf("fatal: could not: %s\n", input);
+                    perror("fatal: could not fileno INPUT_FILENAME");
+                    exit(1);
+                }
+                dup2(input_fd, arg1);
+                close(input_fd);
+            }
             if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))
                 return -TARGET_EFAULT;
             ret = get_errno(safe_read(arg1, p, arg3));
@@ -6966,8 +6405,16 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
         }
         return ret;
     case TARGET_NR_write:
+        if ((is_socket >> arg1) & 1){
+            // TODO: Julian, can you checkout how to patch this properly?
+            sent = true;
+        }
         if (arg2 == 0 && arg3 == 0) {
-            return get_errno(safe_write(arg1, 0, 0));
+            if(!create_outputs) {
+                return 0;
+            } else {
+                return get_errno(safe_write(arg1, 0, 0));
+            }
         }
         if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))
             return -TARGET_EFAULT;
@@ -6976,11 +6423,27 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
             memcpy(copy, p, arg3);
             ret = fd_trans_target_to_host_data(arg1)(copy, arg3);
             if (ret >= 0) {
-                ret = get_errno(safe_write(arg1, copy, ret));
+                if(create_outputs) {
+                    ret = get_errno(safe_write(arg1, copy, ret));
+                }
             }
             g_free(copy);
         } else {
-            ret = get_errno(safe_write(arg1, p, arg3));
+            if(!create_outputs) {
+                _ = system("ls -la /proc/self/fd > /tmp/fitm-arg3");
+                ret = arg3;
+            } else {
+                _ = system("ls -la /proc/self/fd > /tmp/fitm-safewrite2");
+                FILE *fp;
+                char *uuid = get_new_uuid();
+                char path[49] = "/tmp/fitm-";
+                strncat(path, uuid, 37);
+                fp = fopen(path, "w+");
+                fprintf(fp, "arg1: %ld\np: %s\narg3: %ld", arg1, (char *)p, arg3);
+                fclose(fp);
+
+                ret = get_errno(safe_write(arg1, p, arg3));
+            }
         }
         unlock_user(p, arg2, 0);
         return ret;
@@ -8564,7 +8027,7 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
 #endif
 #ifdef TARGET_NR_socketcall
     case TARGET_NR_socketcall:
-        return do_socketcall(arg1, arg2);
+        return do_socketcall(cpu, arg1, arg2);
 #endif
 #ifdef TARGET_NR_accept
     case TARGET_NR_accept:
@@ -8596,15 +8059,15 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
 #endif
 #ifdef TARGET_NR_listen
     case TARGET_NR_listen:
-        return get_errno(listen(arg1, arg2));
+        return 0;
 #endif
 #ifdef TARGET_NR_recv
     case TARGET_NR_recv:
-        return do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);
+        return do_recvfrom(cpu, arg1, arg2, arg3, arg4, 0, 0);
 #endif
 #ifdef TARGET_NR_recvfrom
     case TARGET_NR_recvfrom:
-        return do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);
+        return do_recvfrom(cpu, arg1, arg2, arg3, arg4, arg5, arg6);
 #endif
 #ifdef TARGET_NR_recvmsg
     case TARGET_NR_recvmsg:
@@ -8630,6 +8093,7 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
 #endif
 #ifdef TARGET_NR_shutdown
     case TARGET_NR_shutdown:
+        is_socket &= ~(long long int)(1 << arg1);
         return get_errno(shutdown(arg1, arg2));
 #endif
 #if defined(TARGET_NR_getrandom) && defined(__NR_getrandom)
@@ -9992,7 +9456,7 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
         return get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));
 #if defined(TARGET_NR_fchownat)
     case TARGET_NR_fchownat:
-        if (!(p = lock_user_string(arg2))) 
+        if (!(p = lock_user_string(arg2)))
             return -TARGET_EFAULT;
         ret = get_errno(fchownat(arg1, p, low2highuid(arg3),
                                  low2highgid(arg4), arg5));
diff --git a/qemu/qemu/roms/seabios/config.mak b/qemu/qemu/roms/seabios/config.mak
index 1c194ec4..014dc8a1 100644
--- a/qemu/qemu/roms/seabios/config.mak
+++ b/qemu/qemu/roms/seabios/config.mak
@@ -1,5 +1,5 @@
 # Automatically generated by configure - do not modify
-SRC_PATH=/home/xcv/repos/FitM/qemu/roms/seabios
+SRC_PATH=/mnt/c/Users/dcmai/tmp/FitM/qemu/qemu/roms/seabios
 AS=as
 CCAS=cc
 CC=cc
diff --git a/qemu/qemu/roms/vgabios/config.mak b/qemu/qemu/roms/vgabios/config.mak
index 10515b7d..d6a5ffe5 100644
--- a/qemu/qemu/roms/vgabios/config.mak
+++ b/qemu/qemu/roms/vgabios/config.mak
@@ -1,5 +1,5 @@
 # Automatically generated by configure - do not modify
-SRC_PATH=/home/xcv/repos/FitM/qemu/roms/vgabios
+SRC_PATH=/mnt/c/Users/dcmai/tmp/FitM/qemu/qemu/roms/vgabios
 AS=as
 CCAS=cc
 CC=cc
