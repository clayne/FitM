--- ./qemu/linux-user/syscall.c.orig	2021-01-05 16:51:19.023365000 +0100
+++ ./qemu/linux-user/syscall.c	2021-01-05 16:51:19.023365000 +0100
@@ -47,6 +47,7 @@
 #include <utime.h>
 #include <sys/sysinfo.h>
 #include <sys/signalfd.h>
+#include <stdbool.h>
 //#include <sys/user.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
@@ -111,6 +112,36 @@
 
 #include "qemu.h"
 #include "fd-trans.h"
+#include <linux/sockios.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <fcntl.h>
+
+#include "criu.h"
+
+#include "tcg/tcg-op.h"
+
+#include "../../patches/afl-qemu-common.h"
+
+// Filedescriptors used by AFL to communicate between forkserver & child
+#define FRKSRV_READ_FD             (198)
+#define FRKSRV_WRITE_FD            (199)
+
+// The next receive after send should create a snapshot
+// Idea is: We're waiting for a return from the other side then
+bool sent = true;
+// If true, we are supposed to write the outputs to a file.
+bool create_outputs = true; //TODO: works? getenv_from_file("FITM_CREATE_OUTPUTS");
+// If true, please do snapshot.
+// we are restored or snapshottet or something.
+bool timewarp_mode = true; //TODO: works? getenv_from_file("LETS_DO_THE_TIMEWARP_AGAIN");
+// every position in this bitstring is interpreted as a fd. pos x == fd x
+// If a position holds a 1 it is a socket
+long long int is_socket = 0;
+
+
+extern unsigned int afl_forksrv_pid;
 
 #ifndef CLONE_IO
 #define CLONE_IO                0x80000000      /* Clone io context */
@@ -250,7 +281,8 @@
 #endif
 
 #ifdef __NR_gettid
-_syscall0(int, gettid)
+#define __NR_sys_gettid __NR_gettid
+_syscall0(int, sys_gettid)
 #else
 /* This is a replacement for the host gettid() and must return a host
    errno. */
@@ -752,19 +784,11 @@
               unsigned long, pos_l, unsigned long, pos_h)
 safe_syscall5(ssize_t, pwritev, int, fd, const struct iovec *, iov, int, iovcnt,
               unsigned long, pos_l, unsigned long, pos_h)
-safe_syscall3(int, connect, int, fd, const struct sockaddr *, addr,
-              socklen_t, addrlen)
-safe_syscall6(ssize_t, sendto, int, fd, const void *, buf, size_t, len,
-              int, flags, const struct sockaddr *, addr, socklen_t, addrlen)
-safe_syscall6(ssize_t, recvfrom, int, fd, void *, buf, size_t, len,
-              int, flags, struct sockaddr *, addr, socklen_t *, addrlen)
 safe_syscall3(ssize_t, sendmsg, int, fd, const struct msghdr *, msg, int, flags)
 safe_syscall3(ssize_t, recvmsg, int, fd, struct msghdr *, msg, int, flags)
 safe_syscall2(int, flock, int, fd, int, operation)
 safe_syscall4(int, rt_sigtimedwait, const sigset_t *, these, siginfo_t *, uinfo,
               const struct timespec *, uts, size_t, sigsetsize)
-safe_syscall4(int, accept4, int, fd, struct sockaddr *, addr, socklen_t *, len,
-              int, flags)
 safe_syscall2(int, nanosleep, const struct timespec *, req,
               struct timespec *, rem)
 #ifdef TARGET_NR_clock_nanosleep
@@ -1077,7 +1101,7 @@
 {
     abi_ulong target_rlim_swap;
     rlim_t result;
-    
+
     target_rlim_swap = tswapal(target_rlim);
     if (target_rlim_swap == TARGET_RLIM_INFINITY)
         return RLIM_INFINITY;
@@ -1085,7 +1109,7 @@
     result = target_rlim_swap;
     if (target_rlim_swap != (rlim_t)result)
         return RLIM_INFINITY;
-    
+
     return result;
 }
 
@@ -1093,13 +1117,13 @@
 {
     abi_ulong target_rlim_swap;
     abi_ulong result;
-    
+
     if (rlim == RLIM_INFINITY || rlim != (abi_long)rlim)
         target_rlim_swap = TARGET_RLIM_INFINITY;
     else
         target_rlim_swap = rlim;
     result = tswapal(target_rlim_swap);
-    
+
     return result;
 }
 
@@ -1478,9 +1502,9 @@
     abi_ulong target_cmsg_addr;
     struct target_cmsghdr *target_cmsg, *target_cmsg_start;
     socklen_t space = 0;
-    
+
     msg_controllen = tswapal(target_msgh->msg_controllen);
-    if (msg_controllen < sizeof (struct target_cmsghdr)) 
+    if (msg_controllen < sizeof (struct target_cmsghdr))
         goto the_end;
     target_cmsg_addr = tswapal(target_msgh->msg_control);
     target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);
@@ -1562,7 +1586,7 @@
     socklen_t space = 0;
 
     msg_controllen = tswapal(target_msgh->msg_controllen);
-    if (msg_controllen < sizeof (struct target_cmsghdr)) 
+    if (msg_controllen < sizeof (struct target_cmsghdr))
         goto the_end;
     target_cmsg_addr = tswapal(target_msgh->msg_control);
     target_cmsg = lock_user(VERIFY_WRITE, target_cmsg_addr, msg_controllen, 0);
@@ -1788,578 +1812,14 @@
 static abi_long do_setsockopt(int sockfd, int level, int optname,
                               abi_ulong optval_addr, socklen_t optlen)
 {
-    abi_long ret;
-    int val;
-    struct ip_mreqn *ip_mreq;
-    struct ip_mreq_source *ip_mreq_source;
-
-    switch(level) {
-    case SOL_TCP:
-        /* TCP options all take an 'int' value.  */
-        if (optlen < sizeof(uint32_t))
-            return -TARGET_EINVAL;
-
-        if (get_user_u32(val, optval_addr))
-            return -TARGET_EFAULT;
-        ret = get_errno(setsockopt(sockfd, level, optname, &val, sizeof(val)));
-        break;
-    case SOL_IP:
-        switch(optname) {
-        case IP_TOS:
-        case IP_TTL:
-        case IP_HDRINCL:
-        case IP_ROUTER_ALERT:
-        case IP_RECVOPTS:
-        case IP_RETOPTS:
-        case IP_PKTINFO:
-        case IP_MTU_DISCOVER:
-        case IP_RECVERR:
-        case IP_RECVTTL:
-        case IP_RECVTOS:
-#ifdef IP_FREEBIND
-        case IP_FREEBIND:
-#endif
-        case IP_MULTICAST_TTL:
-        case IP_MULTICAST_LOOP:
-            val = 0;
-            if (optlen >= sizeof(uint32_t)) {
-                if (get_user_u32(val, optval_addr))
-                    return -TARGET_EFAULT;
-            } else if (optlen >= 1) {
-                if (get_user_u8(val, optval_addr))
-                    return -TARGET_EFAULT;
-            }
-            ret = get_errno(setsockopt(sockfd, level, optname, &val, sizeof(val)));
-            break;
-        case IP_ADD_MEMBERSHIP:
-        case IP_DROP_MEMBERSHIP:
-            if (optlen < sizeof (struct target_ip_mreq) ||
-                optlen > sizeof (struct target_ip_mreqn))
-                return -TARGET_EINVAL;
-
-            ip_mreq = (struct ip_mreqn *) alloca(optlen);
-            target_to_host_ip_mreq(ip_mreq, optval_addr, optlen);
-            ret = get_errno(setsockopt(sockfd, level, optname, ip_mreq, optlen));
-            break;
-
-        case IP_BLOCK_SOURCE:
-        case IP_UNBLOCK_SOURCE:
-        case IP_ADD_SOURCE_MEMBERSHIP:
-        case IP_DROP_SOURCE_MEMBERSHIP:
-            if (optlen != sizeof (struct target_ip_mreq_source))
-                return -TARGET_EINVAL;
-
-            ip_mreq_source = lock_user(VERIFY_READ, optval_addr, optlen, 1);
-            ret = get_errno(setsockopt(sockfd, level, optname, ip_mreq_source, optlen));
-            unlock_user (ip_mreq_source, optval_addr, 0);
-            break;
-
-        default:
-            goto unimplemented;
-        }
-        break;
-    case SOL_IPV6:
-        switch (optname) {
-        case IPV6_MTU_DISCOVER:
-        case IPV6_MTU:
-        case IPV6_V6ONLY:
-        case IPV6_RECVPKTINFO:
-        case IPV6_UNICAST_HOPS:
-        case IPV6_MULTICAST_HOPS:
-        case IPV6_MULTICAST_LOOP:
-        case IPV6_RECVERR:
-        case IPV6_RECVHOPLIMIT:
-        case IPV6_2292HOPLIMIT:
-        case IPV6_CHECKSUM:
-            val = 0;
-            if (optlen < sizeof(uint32_t)) {
-                return -TARGET_EINVAL;
-            }
-            if (get_user_u32(val, optval_addr)) {
-                return -TARGET_EFAULT;
-            }
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &val, sizeof(val)));
-            break;
-        case IPV6_PKTINFO:
-        {
-            struct in6_pktinfo pki;
-
-            if (optlen < sizeof(pki)) {
-                return -TARGET_EINVAL;
-            }
-
-            if (copy_from_user(&pki, optval_addr, sizeof(pki))) {
-                return -TARGET_EFAULT;
-            }
-
-            pki.ipi6_ifindex = tswap32(pki.ipi6_ifindex);
-
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &pki, sizeof(pki)));
-            break;
-        }
-        default:
-            goto unimplemented;
-        }
-        break;
-    case SOL_ICMPV6:
-        switch (optname) {
-        case ICMPV6_FILTER:
-        {
-            struct icmp6_filter icmp6f;
-
-            if (optlen > sizeof(icmp6f)) {
-                optlen = sizeof(icmp6f);
-            }
-
-            if (copy_from_user(&icmp6f, optval_addr, optlen)) {
-                return -TARGET_EFAULT;
-            }
-
-            for (val = 0; val < 8; val++) {
-                icmp6f.data[val] = tswap32(icmp6f.data[val]);
-            }
-
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &icmp6f, optlen));
-            break;
-        }
-        default:
-            goto unimplemented;
-        }
-        break;
-    case SOL_RAW:
-        switch (optname) {
-        case ICMP_FILTER:
-        case IPV6_CHECKSUM:
-            /* those take an u32 value */
-            if (optlen < sizeof(uint32_t)) {
-                return -TARGET_EINVAL;
-            }
-
-            if (get_user_u32(val, optval_addr)) {
-                return -TARGET_EFAULT;
-            }
-            ret = get_errno(setsockopt(sockfd, level, optname,
-                                       &val, sizeof(val)));
-            break;
-
-        default:
-            goto unimplemented;
-        }
-        break;
-    case TARGET_SOL_SOCKET:
-        switch (optname) {
-        case TARGET_SO_RCVTIMEO:
-        {
-                struct timeval tv;
-
-                optname = SO_RCVTIMEO;
-
-set_timeout:
-                if (optlen != sizeof(struct target_timeval)) {
-                    return -TARGET_EINVAL;
-                }
-
-                if (copy_from_user_timeval(&tv, optval_addr)) {
-                    return -TARGET_EFAULT;
-                }
-
-                ret = get_errno(setsockopt(sockfd, SOL_SOCKET, optname,
-                                &tv, sizeof(tv)));
-                return ret;
-        }
-        case TARGET_SO_SNDTIMEO:
-                optname = SO_SNDTIMEO;
-                goto set_timeout;
-        case TARGET_SO_ATTACH_FILTER:
-        {
-                struct target_sock_fprog *tfprog;
-                struct target_sock_filter *tfilter;
-                struct sock_fprog fprog;
-                struct sock_filter *filter;
-                int i;
-
-                if (optlen != sizeof(*tfprog)) {
-                    return -TARGET_EINVAL;
-                }
-                if (!lock_user_struct(VERIFY_READ, tfprog, optval_addr, 0)) {
-                    return -TARGET_EFAULT;
-                }
-                if (!lock_user_struct(VERIFY_READ, tfilter,
-                                      tswapal(tfprog->filter), 0)) {
-                    unlock_user_struct(tfprog, optval_addr, 1);
-                    return -TARGET_EFAULT;
-                }
-
-                fprog.len = tswap16(tfprog->len);
-                filter = g_try_new(struct sock_filter, fprog.len);
-                if (filter == NULL) {
-                    unlock_user_struct(tfilter, tfprog->filter, 1);
-                    unlock_user_struct(tfprog, optval_addr, 1);
-                    return -TARGET_ENOMEM;
-                }
-                for (i = 0; i < fprog.len; i++) {
-                    filter[i].code = tswap16(tfilter[i].code);
-                    filter[i].jt = tfilter[i].jt;
-                    filter[i].jf = tfilter[i].jf;
-                    filter[i].k = tswap32(tfilter[i].k);
-                }
-                fprog.filter = filter;
-
-                ret = get_errno(setsockopt(sockfd, SOL_SOCKET,
-                                SO_ATTACH_FILTER, &fprog, sizeof(fprog)));
-                g_free(filter);
-
-                unlock_user_struct(tfilter, tfprog->filter, 1);
-                unlock_user_struct(tfprog, optval_addr, 1);
-                return ret;
-        }
-	case TARGET_SO_BINDTODEVICE:
-	{
-		char *dev_ifname, *addr_ifname;
-
-		if (optlen > IFNAMSIZ - 1) {
-		    optlen = IFNAMSIZ - 1;
-		}
-		dev_ifname = lock_user(VERIFY_READ, optval_addr, optlen, 1);
-		if (!dev_ifname) {
-		    return -TARGET_EFAULT;
-		}
-		optname = SO_BINDTODEVICE;
-		addr_ifname = alloca(IFNAMSIZ);
-		memcpy(addr_ifname, dev_ifname, optlen);
-		addr_ifname[optlen] = 0;
-		ret = get_errno(setsockopt(sockfd, SOL_SOCKET, optname,
-                                           addr_ifname, optlen));
-		unlock_user (dev_ifname, optval_addr, 0);
-		return ret;
-	}
-        case TARGET_SO_LINGER:
-        {
-                struct linger lg;
-                struct target_linger *tlg;
-
-                if (optlen != sizeof(struct target_linger)) {
-                    return -TARGET_EINVAL;
-                }
-                if (!lock_user_struct(VERIFY_READ, tlg, optval_addr, 1)) {
-                    return -TARGET_EFAULT;
-                }
-                __get_user(lg.l_onoff, &tlg->l_onoff);
-                __get_user(lg.l_linger, &tlg->l_linger);
-                ret = get_errno(setsockopt(sockfd, SOL_SOCKET, SO_LINGER,
-                                &lg, sizeof(lg)));
-                unlock_user_struct(tlg, optval_addr, 0);
-                return ret;
-        }
-            /* Options with 'int' argument.  */
-        case TARGET_SO_DEBUG:
-		optname = SO_DEBUG;
-		break;
-        case TARGET_SO_REUSEADDR:
-		optname = SO_REUSEADDR;
-		break;
-#ifdef SO_REUSEPORT
-        case TARGET_SO_REUSEPORT:
-                optname = SO_REUSEPORT;
-                break;
-#endif
-        case TARGET_SO_TYPE:
-		optname = SO_TYPE;
-		break;
-        case TARGET_SO_ERROR:
-		optname = SO_ERROR;
-		break;
-        case TARGET_SO_DONTROUTE:
-		optname = SO_DONTROUTE;
-		break;
-        case TARGET_SO_BROADCAST:
-		optname = SO_BROADCAST;
-		break;
-        case TARGET_SO_SNDBUF:
-		optname = SO_SNDBUF;
-		break;
-        case TARGET_SO_SNDBUFFORCE:
-                optname = SO_SNDBUFFORCE;
-                break;
-        case TARGET_SO_RCVBUF:
-		optname = SO_RCVBUF;
-		break;
-        case TARGET_SO_RCVBUFFORCE:
-                optname = SO_RCVBUFFORCE;
-                break;
-        case TARGET_SO_KEEPALIVE:
-		optname = SO_KEEPALIVE;
-		break;
-        case TARGET_SO_OOBINLINE:
-		optname = SO_OOBINLINE;
-		break;
-        case TARGET_SO_NO_CHECK:
-		optname = SO_NO_CHECK;
-		break;
-        case TARGET_SO_PRIORITY:
-		optname = SO_PRIORITY;
-		break;
-#ifdef SO_BSDCOMPAT
-        case TARGET_SO_BSDCOMPAT:
-		optname = SO_BSDCOMPAT;
-		break;
-#endif
-        case TARGET_SO_PASSCRED:
-		optname = SO_PASSCRED;
-		break;
-        case TARGET_SO_PASSSEC:
-                optname = SO_PASSSEC;
-                break;
-        case TARGET_SO_TIMESTAMP:
-		optname = SO_TIMESTAMP;
-		break;
-        case TARGET_SO_RCVLOWAT:
-		optname = SO_RCVLOWAT;
-		break;
-        default:
-            goto unimplemented;
-        }
-	if (optlen < sizeof(uint32_t))
-            return -TARGET_EINVAL;
-
-	if (get_user_u32(val, optval_addr))
-            return -TARGET_EFAULT;
-	ret = get_errno(setsockopt(sockfd, SOL_SOCKET, optname, &val, sizeof(val)));
-        break;
-    default:
-    unimplemented:
-        gemu_log("Unsupported setsockopt level=%d optname=%d\n", level, optname);
-        ret = -TARGET_ENOPROTOOPT;
-    }
-    return ret;
+    return 0;
 }
 
 /* do_getsockopt() Must return target values and target errnos. */
 static abi_long do_getsockopt(int sockfd, int level, int optname,
                               abi_ulong optval_addr, abi_ulong optlen)
 {
-    abi_long ret;
-    int len, val;
-    socklen_t lv;
-
-    switch(level) {
-    case TARGET_SOL_SOCKET:
-        level = SOL_SOCKET;
-        switch (optname) {
-        /* These don't just return a single integer */
-        case TARGET_SO_RCVTIMEO:
-        case TARGET_SO_SNDTIMEO:
-        case TARGET_SO_PEERNAME:
-            goto unimplemented;
-        case TARGET_SO_PEERCRED: {
-            struct ucred cr;
-            socklen_t crlen;
-            struct target_ucred *tcr;
-
-            if (get_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            if (len < 0) {
-                return -TARGET_EINVAL;
-            }
-
-            crlen = sizeof(cr);
-            ret = get_errno(getsockopt(sockfd, level, SO_PEERCRED,
-                                       &cr, &crlen));
-            if (ret < 0) {
-                return ret;
-            }
-            if (len > crlen) {
-                len = crlen;
-            }
-            if (!lock_user_struct(VERIFY_WRITE, tcr, optval_addr, 0)) {
-                return -TARGET_EFAULT;
-            }
-            __put_user(cr.pid, &tcr->pid);
-            __put_user(cr.uid, &tcr->uid);
-            __put_user(cr.gid, &tcr->gid);
-            unlock_user_struct(tcr, optval_addr, 1);
-            if (put_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            break;
-        }
-        case TARGET_SO_LINGER:
-        {
-            struct linger lg;
-            socklen_t lglen;
-            struct target_linger *tlg;
-
-            if (get_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            if (len < 0) {
-                return -TARGET_EINVAL;
-            }
-
-            lglen = sizeof(lg);
-            ret = get_errno(getsockopt(sockfd, level, SO_LINGER,
-                                       &lg, &lglen));
-            if (ret < 0) {
-                return ret;
-            }
-            if (len > lglen) {
-                len = lglen;
-            }
-            if (!lock_user_struct(VERIFY_WRITE, tlg, optval_addr, 0)) {
-                return -TARGET_EFAULT;
-            }
-            __put_user(lg.l_onoff, &tlg->l_onoff);
-            __put_user(lg.l_linger, &tlg->l_linger);
-            unlock_user_struct(tlg, optval_addr, 1);
-            if (put_user_u32(len, optlen)) {
-                return -TARGET_EFAULT;
-            }
-            break;
-        }
-        /* Options with 'int' argument.  */
-        case TARGET_SO_DEBUG:
-            optname = SO_DEBUG;
-            goto int_case;
-        case TARGET_SO_REUSEADDR:
-            optname = SO_REUSEADDR;
-            goto int_case;
-#ifdef SO_REUSEPORT
-        case TARGET_SO_REUSEPORT:
-            optname = SO_REUSEPORT;
-            goto int_case;
-#endif
-        case TARGET_SO_TYPE:
-            optname = SO_TYPE;
-            goto int_case;
-        case TARGET_SO_ERROR:
-            optname = SO_ERROR;
-            goto int_case;
-        case TARGET_SO_DONTROUTE:
-            optname = SO_DONTROUTE;
-            goto int_case;
-        case TARGET_SO_BROADCAST:
-            optname = SO_BROADCAST;
-            goto int_case;
-        case TARGET_SO_SNDBUF:
-            optname = SO_SNDBUF;
-            goto int_case;
-        case TARGET_SO_RCVBUF:
-            optname = SO_RCVBUF;
-            goto int_case;
-        case TARGET_SO_KEEPALIVE:
-            optname = SO_KEEPALIVE;
-            goto int_case;
-        case TARGET_SO_OOBINLINE:
-            optname = SO_OOBINLINE;
-            goto int_case;
-        case TARGET_SO_NO_CHECK:
-            optname = SO_NO_CHECK;
-            goto int_case;
-        case TARGET_SO_PRIORITY:
-            optname = SO_PRIORITY;
-            goto int_case;
-#ifdef SO_BSDCOMPAT
-        case TARGET_SO_BSDCOMPAT:
-            optname = SO_BSDCOMPAT;
-            goto int_case;
-#endif
-        case TARGET_SO_PASSCRED:
-            optname = SO_PASSCRED;
-            goto int_case;
-        case TARGET_SO_TIMESTAMP:
-            optname = SO_TIMESTAMP;
-            goto int_case;
-        case TARGET_SO_RCVLOWAT:
-            optname = SO_RCVLOWAT;
-            goto int_case;
-        case TARGET_SO_ACCEPTCONN:
-            optname = SO_ACCEPTCONN;
-            goto int_case;
-        default:
-            goto int_case;
-        }
-        break;
-    case SOL_TCP:
-        /* TCP options all take an 'int' value.  */
-    int_case:
-        if (get_user_u32(len, optlen))
-            return -TARGET_EFAULT;
-        if (len < 0)
-            return -TARGET_EINVAL;
-        lv = sizeof(lv);
-        ret = get_errno(getsockopt(sockfd, level, optname, &val, &lv));
-        if (ret < 0)
-            return ret;
-        if (optname == SO_TYPE) {
-            val = host_to_target_sock_type(val);
-        }
-        if (len > lv)
-            len = lv;
-        if (len == 4) {
-            if (put_user_u32(val, optval_addr))
-                return -TARGET_EFAULT;
-        } else {
-            if (put_user_u8(val, optval_addr))
-                return -TARGET_EFAULT;
-        }
-        if (put_user_u32(len, optlen))
-            return -TARGET_EFAULT;
-        break;
-    case SOL_IP:
-        switch(optname) {
-        case IP_TOS:
-        case IP_TTL:
-        case IP_HDRINCL:
-        case IP_ROUTER_ALERT:
-        case IP_RECVOPTS:
-        case IP_RETOPTS:
-        case IP_PKTINFO:
-        case IP_MTU_DISCOVER:
-        case IP_RECVERR:
-        case IP_RECVTOS:
-#ifdef IP_FREEBIND
-        case IP_FREEBIND:
-#endif
-        case IP_MULTICAST_TTL:
-        case IP_MULTICAST_LOOP:
-            if (get_user_u32(len, optlen))
-                return -TARGET_EFAULT;
-            if (len < 0)
-                return -TARGET_EINVAL;
-            lv = sizeof(lv);
-            ret = get_errno(getsockopt(sockfd, level, optname, &val, &lv));
-            if (ret < 0)
-                return ret;
-            if (len < sizeof(int) && len > 0 && val >= 0 && val < 255) {
-                len = 1;
-                if (put_user_u32(len, optlen)
-                    || put_user_u8(val, optval_addr))
-                    return -TARGET_EFAULT;
-            } else {
-                if (len > sizeof(int))
-                    len = sizeof(int);
-                if (put_user_u32(len, optlen)
-                    || put_user_u32(val, optval_addr))
-                    return -TARGET_EFAULT;
-            }
-            break;
-        default:
-            ret = -TARGET_ENOPROTOOPT;
-            break;
-        }
-        break;
-    default:
-    unimplemented:
-        gemu_log("getsockopt level=%d optname=%d not yet supported\n",
-                 level, optname);
-        ret = -TARGET_EOPNOTSUPP;
-        break;
-    }
-    return ret;
+    return 0;
 }
 
 /* Convert target low/high pair representing file offset into the host
@@ -2524,113 +1984,36 @@
     return 0;
 }
 
-/* Try to emulate socket type flags after socket creation.  */
-static int sock_flags_fixup(int fd, int target_type)
-{
-#if !defined(SOCK_NONBLOCK) && defined(O_NONBLOCK)
-    if (target_type & TARGET_SOCK_NONBLOCK) {
-        int flags = fcntl(fd, F_GETFL);
-        if (fcntl(fd, F_SETFL, O_NONBLOCK | flags) == -1) {
-            close(fd);
-            return -TARGET_EINVAL;
-        }
-    }
-#endif
-    return fd;
-}
-
 /* do_socket() Must return target values and target errnos. */
 static abi_long do_socket(int domain, int type, int protocol)
 {
-    int target_type = type;
-    int ret;
-
-    ret = target_to_host_sock_type(&type);
-    if (ret) {
-        return ret;
-    }
-
-    if (domain == PF_NETLINK && !(
-#ifdef CONFIG_RTNETLINK
-         protocol == NETLINK_ROUTE ||
-#endif
-         protocol == NETLINK_KOBJECT_UEVENT ||
-         protocol == NETLINK_AUDIT)) {
-        return -EPFNOSUPPORT;
-    }
+    char *uuid = get_new_uuid();
+    char path[44] = "./fd/";
+    strncat(path, uuid, 37);
+
+    int new_fd = open(path, O_RDWR | O_CREAT, 0666);
+    chmod(path, 0666);
+    is_socket |= 1 << new_fd;
 
-    if (domain == AF_PACKET ||
-        (domain == AF_INET && type == SOCK_PACKET)) {
-        protocol = tswap16(protocol);
-    }
-
-    ret = get_errno(socket(domain, type, protocol));
-    if (ret >= 0) {
-        ret = sock_flags_fixup(ret, target_type);
-        if (type == SOCK_PACKET) {
-            /* Manage an obsolete case :
-             * if socket type is SOCK_PACKET, bind by name
-             */
-            fd_trans_register(ret, &target_packet_trans);
-        } else if (domain == PF_NETLINK) {
-            switch (protocol) {
-#ifdef CONFIG_RTNETLINK
-            case NETLINK_ROUTE:
-                fd_trans_register(ret, &target_netlink_route_trans);
-                break;
-#endif
-            case NETLINK_KOBJECT_UEVENT:
-                /* nothing to do: messages are strings */
-                break;
-            case NETLINK_AUDIT:
-                fd_trans_register(ret, &target_netlink_audit_trans);
-                break;
-            default:
-                g_assert_not_reached();
-            }
-        }
-    }
-    return ret;
+    return new_fd;
 }
 
 /* do_bind() Must return target values and target errnos. */
 static abi_long do_bind(int sockfd, abi_ulong target_addr,
                         socklen_t addrlen)
 {
-    void *addr;
-    abi_long ret;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    addr = alloca(addrlen+1);
-
-    ret = target_to_host_sockaddr(sockfd, addr, target_addr, addrlen);
-    if (ret)
-        return ret;
-
-    return get_errno(bind(sockfd, addr, addrlen));
+    // Adress binding always works as we are only writing to a file
+    // check: https://github.com/zardus/preeny/blob/master/src/desock.c#L259
+    return 0;
 }
 
 /* do_connect() Must return target values and target errnos. */
 static abi_long do_connect(int sockfd, abi_ulong target_addr,
                            socklen_t addrlen)
 {
-    void *addr;
-    abi_long ret;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    addr = alloca(addrlen+1);
-
-    ret = target_to_host_sockaddr(sockfd, addr, target_addr, addrlen);
-    if (ret)
-        return ret;
-
-    return get_errno(safe_connect(sockfd, addr, addrlen));
+    // Connecting to a remote adr. always works as we are only running locally
+    // Check: https://github.com/zardus/preeny/blob/master/src/desock.c#L275
+    return 0;
 }
 
 /* do_sendrecvmsg_locked() Must return target values and target errnos. */
@@ -2807,37 +2190,15 @@
 static abi_long do_accept4(int fd, abi_ulong target_addr,
                            abi_ulong target_addrlen_addr, int flags)
 {
-    socklen_t addrlen;
-    void *addr;
-    abi_long ret;
-    int host_flags;
-
-    host_flags = target_to_host_bitmask(flags, fcntl_flags_tbl);
-
-    if (target_addr == 0) {
-        return get_errno(safe_accept4(fd, NULL, NULL, host_flags));
-    }
-
-    /* linux returns EINVAL if addrlen pointer is invalid */
-    if (get_user_u32(addrlen, target_addrlen_addr))
-        return -TARGET_EINVAL;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    if (!access_ok(VERIFY_WRITE, target_addr, addrlen))
-        return -TARGET_EINVAL;
+    char *uuid = get_new_uuid();
+    char path[44] = "./fd/";
+    strncat(path, uuid, 37);
+
+    int new_fd = open(path, O_RDWR | O_CREAT, 0666);
+    chmod(path, 0666);
+    is_socket |= 1 << new_fd;
 
-    addr = alloca(addrlen);
-
-    ret = get_errno(safe_accept4(fd, addr, &addrlen, host_flags));
-    if (!is_error(ret)) {
-        host_to_target_sockaddr(target_addr, addr, addrlen);
-        if (put_user_u32(addrlen, target_addrlen_addr))
-            ret = -TARGET_EFAULT;
-    }
-    return ret;
+    return new_fd;
 }
 
 /* do_getpeername() Must return target values and target errnos. */
@@ -2920,102 +2281,113 @@
 static abi_long do_sendto(int fd, abi_ulong msg, size_t len, int flags,
                           abi_ulong target_addr, socklen_t addrlen)
 {
-    void *addr;
-    void *host_msg;
-    void *copy_msg = NULL;
-    abi_long ret;
-
-    if ((int)addrlen < 0) {
-        return -TARGET_EINVAL;
-    }
-
-    host_msg = lock_user(VERIFY_READ, msg, len, 1);
-    if (!host_msg)
-        return -TARGET_EFAULT;
-    if (fd_trans_target_to_host_data(fd)) {
-        copy_msg = host_msg;
-        host_msg = g_malloc(len);
-        memcpy(host_msg, copy_msg, len);
-        ret = fd_trans_target_to_host_data(fd)(host_msg, len);
-        if (ret < 0) {
-            goto fail;
-        }
-    }
-    if (target_addr) {
-        addr = alloca(addrlen+1);
-        ret = target_to_host_sockaddr(fd, addr, target_addr, addrlen);
-        if (ret) {
-            goto fail;
-        }
-        ret = get_errno(safe_sendto(fd, host_msg, len, flags, addr, addrlen));
+    sent = true;
+    // Only write sth to the fd if we are in consolidation
+    if(!create_outputs) {
+        return (ssize_t)len;
     } else {
-        ret = get_errno(safe_sendto(fd, host_msg, len, flags, NULL, 0));
-    }
-fail:
-    if (copy_msg) {
-        g_free(host_msg);
-        host_msg = copy_msg;
+        FILE *fp;
+        char *uuid = get_new_uuid();
+        char path[49] = "/tmp/fitm-";
+        strncat(path, uuid, 37);
+        fp = fopen(path, "w+");
+        fprintf(fp, "fd: %d\nmsg: %s\nlen: %ld", fd, (char *)msg, len);
+        fclose(fp);
+
+        _ = system("ls -la /proc/self/fd > /tmp/fitm-sendto");
+        return write(fd, (char *) msg, len);
     }
-    unlock_user(host_msg, msg, 0);
-    return ret;
 }
 
 /* do_recvfrom() Must return target values and target errnos. */
-static abi_long do_recvfrom(int fd, abi_ulong msg, size_t len, int flags,
+static abi_long do_recvfrom(CPUState *cpu, int fd, abi_ulong msg, size_t len, int flags,
                             abi_ulong target_addr,
                             abi_ulong target_addrlen)
 {
-    socklen_t addrlen;
-    void *addr;
-    void *host_msg;
-    abi_long ret;
 
-    host_msg = lock_user(VERIFY_WRITE, msg, len, 0);
-    if (!host_msg)
-        return -TARGET_EFAULT;
-    if (target_addr) {
-        if (get_user_u32(addrlen, target_addrlen)) {
-            ret = -TARGET_EFAULT;
-            goto fail;
+    if(sent){
+        if (!timewarp_mode) {
+            exit(0);
+        }
+        sent = false; // After restore, we'll await the next sent before criuin' again
+
+        if (fcntl(FRKSRV_READ_FD, F_GETFD) == -1) {
+            int read_pipe[2];
+            int write_pipe[2];
+            if (pipe(read_pipe) == -1) {
+                printf("QEMU: Could not open AFL Forkserver read pipe!");
+            }
+            if (pipe(write_pipe) == -1) {
+                printf("QEMU: Could not open AFL Forkserver read pipe!");
+            }
+            dup2(read_pipe[0], FRKSRV_READ_FD);
+            dup2(write_pipe[1], FRKSRV_WRITE_FD);
+            close(read_pipe[0]);
+            close(read_pipe[1]);
+            close(write_pipe[0]);
+            close(write_pipe[1]);
+        }
+
+        FILE *f = fopen("./pipes", "w");
+        char *buff = calloc(200, 1);
+        _ = readlink("/proc/self/fd/198", buff, 100);
+        char *tmp = (&buff[strlen(buff)])+1;
+        buff[strlen(buff)] = '\n';
+        _ = readlink("/proc/self/fd/199", tmp, 100);
+        fprintf(f, "%s\n", buff);
+        free(buff);
+        fclose(f);
+
+        // untested, may need debugging
+        close(0);
+        do_criu();
+        // Weird bug making criu restore crash - this solves it
+        sleep(0.2);
+
+	create_outputs = getenv_from_file("FITM_CREATE_OUTPUTS");
+	timewarp_mode = getenv_from_file("LETS_DO_THE_TIMEWARP_AGAIN");
+
+        if (!timewarp_mode) {
+            char* shm_env_var = getenv_from_file(SHM_ENV_VAR);
+            char* afl_inst_ratio = getenv_from_file("AFL_INST_RATIO");
+            if(shm_env_var){
+                afl_setup(shm_env_var, afl_inst_ratio);
+                afl_forkserver(cpu);
+            } else {
+                puts("Forkserver not started, since SHM_ENV_VAR env variable is missing");
+            }
         }
-        if ((int)addrlen < 0) {
-            ret = -TARGET_EINVAL;
-            goto fail;
+
+        // We want to get input from files so we pipe the file we get from AFL through an environment var into here.
+        // The file is used as stdin
+        char* input = getenv_from_file("INPUT_FILENAME");
+        FILE* input_file = fopen(input, "r");
+
+        if(!input_file){
+            printf("fatal: could not fopen INPUT_FILENAME: %s\n", input);
+            exit(1);
         }
-        addr = alloca(addrlen);
-        ret = get_errno(safe_recvfrom(fd, host_msg, len, flags,
-                                      addr, &addrlen));
-    } else {
-        addr = NULL; /* To keep compiler quiet.  */
-        ret = get_errno(safe_recvfrom(fd, host_msg, len, flags, NULL, 0));
-    }
-    if (!is_error(ret)) {
-        if (fd_trans_host_to_target_data(fd)) {
-            abi_long trans;
-            trans = fd_trans_host_to_target_data(fd)(host_msg, MIN(ret, len));
-            if (is_error(trans)) {
-                ret = trans;
-                goto fail;
-            }
+
+        int input_fd = fileno(input_file);
+        if(input_fd == -1){
+            printf("fatal: could not: %s\n", input);
+            perror("fatal: could not fileno INPUT_FILENAME");
+            exit(1);
         }
-        if (target_addr) {
-            host_to_target_sockaddr(target_addr, addr, addrlen);
-            if (put_user_u32(addrlen, target_addrlen)) {
-                ret = -TARGET_EFAULT;
-                goto fail;
-            }
+        // An open may result in INPUT_FILENAME at fd 0 if 0 is not used before calling fopen
+        if(input_fd){
+            dup2(input_fd, 0);
+            close(input_fd);
         }
-        unlock_user(host_msg, msg, len);
-    } else {
-fail:
-        unlock_user(host_msg, msg, 0);
     }
-    return ret;
+    // read did not read anything without setting FD to the beginning of the file.
+//    lseek(0, 0, SEEK_SET);
+    return read(0, (char *)msg, len);
 }
 
 #ifdef TARGET_NR_socketcall
 /* do_socketcall() must return target values and target errnos. */
-static abi_long do_socketcall(int num, abi_ulong vptr)
+static abi_long do_socketcall(CPUState *cpu, int num, abi_ulong vptr)
 {
     static const unsigned nargs[] = { /* number of arguments per operation */
         [TARGET_SYS_SOCKET] = 3,      /* domain, type, protocol */
@@ -3066,7 +2438,7 @@
     case TARGET_SYS_CONNECT: /* sockfd, addr, addrlen */
         return do_connect(a[0], a[1], a[2]);
     case TARGET_SYS_LISTEN: /* sockfd, backlog */
-        return get_errno(listen(a[0], a[1]));
+        return 0;
     case TARGET_SYS_ACCEPT: /* sockfd, addr, addrlen */
         return do_accept4(a[0], a[1], a[2], 0);
     case TARGET_SYS_GETSOCKNAME: /* sockfd, addr, addrlen */
@@ -3078,12 +2450,13 @@
     case TARGET_SYS_SEND: /* sockfd, msg, len, flags */
         return do_sendto(a[0], a[1], a[2], a[3], 0, 0);
     case TARGET_SYS_RECV: /* sockfd, msg, len, flags */
-        return do_recvfrom(a[0], a[1], a[2], a[3], 0, 0);
+        return do_recvfrom(cpu, a[0], a[1], a[2], a[3], 0, 0);
     case TARGET_SYS_SENDTO: /* sockfd, msg, len, flags, addr, addrlen */
         return do_sendto(a[0], a[1], a[2], a[3], a[4], a[5]);
     case TARGET_SYS_RECVFROM: /* sockfd, msg, len, flags, addr, addrlen */
-        return do_recvfrom(a[0], a[1], a[2], a[3], a[4], a[5]);
+        return do_recvfrom(cpu, a[0], a[1], a[2], a[3], a[4], a[5]);
     case TARGET_SYS_SHUTDOWN: /* sockfd, how */
+        is_socket &= ~(long long int)(1 << arg1);
         return get_errno(shutdown(a[0], a[1]));
     case TARGET_SYS_SETSOCKOPT: /* sockfd, level, optname, optval, optlen */
         return do_setsockopt(a[0], a[1], a[2], a[3], a[4]);
@@ -5214,7 +4587,7 @@
     }
     unlock_user_struct(target_ldt_info, ptr, 1);
 
-    if (ldt_info.entry_number < TARGET_GDT_ENTRY_TLS_MIN || 
+    if (ldt_info.entry_number < TARGET_GDT_ENTRY_TLS_MIN ||
         ldt_info.entry_number > TARGET_GDT_ENTRY_TLS_MAX)
            return -TARGET_EINVAL;
     seg_32bit = ldt_info.flags & 1;
@@ -5292,7 +4665,7 @@
     lp = (uint32_t *)(gdt_table + idx);
     entry_1 = tswap32(lp[0]);
     entry_2 = tswap32(lp[1]);
-    
+
     read_exec_only = ((entry_2 >> 9) & 1) ^ 1;
     contents = (entry_2 >> 10) & 3;
     seg_not_present = ((entry_2 >> 15) & 1) ^ 1;
@@ -5308,8 +4681,8 @@
         (read_exec_only << 3) | (limit_in_pages << 4) |
         (seg_not_present << 5) | (useable << 6) | (lm << 7);
     limit = (entry_1 & 0xffff) | (entry_2  & 0xf0000);
-    base_addr = (entry_1 >> 16) | 
-        (entry_2 & 0xff000000) | 
+    base_addr = (entry_1 >> 16) |
+        (entry_2 & 0xff000000) |
         ((entry_2 & 0xff) << 16);
     target_ldt_info->base_addr = tswapal(base_addr);
     target_ldt_info->limit = tswap32(limit);
@@ -5384,7 +4757,7 @@
     cpu = ENV_GET_CPU(env);
     thread_cpu = cpu;
     ts = (TaskState *)cpu->opaque;
-    info->tid = gettid();
+    info->tid = sys_gettid();
     task_settid(ts);
     if (info->child_tidptr)
         put_user_u32(info->tid, info->child_tidptr);
@@ -5529,9 +4902,9 @@
                mapping.  We can't repeat the spinlock hack used above because
                the child process gets its own copy of the lock.  */
             if (flags & CLONE_CHILD_SETTID)
-                put_user_u32(gettid(), child_tidptr);
+                put_user_u32(sys_gettid(), child_tidptr);
             if (flags & CLONE_PARENT_SETTID)
-                put_user_u32(gettid(), parent_tidptr);
+                put_user_u32(sys_gettid(), parent_tidptr);
             ts = (TaskState *)cpu->opaque;
             if (flags & CLONE_SETTLS)
                 cpu_set_tls (env, newtls);
@@ -6774,7 +6147,7 @@
         int fd, r;
 
         /* create temporary file to map stat to */
-        tmpdir = getenv("TMPDIR");
+        tmpdir = getenv_from_file("TMPDIR");
         if (!tmpdir)
             tmpdir = "/tmp";
         snprintf(filename, sizeof(filename), "%s/qemu-open.XXXXXX", tmpdir);
@@ -6908,7 +6281,6 @@
     struct statfs stfs;
 #endif
     void *p;
-
     switch(num) {
     case TARGET_NR_exit:
         /* In old applications this may be used to implement _exit(2).
@@ -6948,9 +6320,80 @@
         _exit(arg1);
         return 0; /* avoid warning */
     case TARGET_NR_read:
-        if (arg3 == 0) {
-            return 0;
-        } else {
+            if (arg3 == 0) {
+                return 0;
+            } else {
+            if(sent && (is_socket >> arg1) & 1){
+                if (!timewarp_mode) {
+                    exit(0);
+                }
+                sent = false; // After restore, we'll await the next sent before criuin' again
+                if (fcntl(FRKSRV_READ_FD, F_GETFD) == -1) {
+                    int read_pipe[2];
+                    int write_pipe[2];
+                    if (pipe(read_pipe) == -1) {
+                        printf("QEMU: Could not open AFL Forkserver read pipe!");
+                    }
+                    if (pipe(write_pipe) == -1) {
+                        printf("QEMU: Could not open AFL Forkserver read pipe!");
+                    }
+                    dup2(read_pipe[0], FRKSRV_READ_FD);
+                    dup2(write_pipe[1], FRKSRV_WRITE_FD);
+                    close(read_pipe[0]);
+                    close(read_pipe[1]);
+                    close(write_pipe[0]);
+                    close(write_pipe[1]);
+                }
+                FILE *f = fopen("./pipes", "w");
+                char *buff = calloc(200, 1);
+                _ = readlink("/proc/self/fd/198", buff, 100);
+                char *tmp = (&buff[strlen(buff)])+1;
+                buff[strlen(buff)] = '\n';
+                _ = readlink("/proc/self/fd/199", tmp, 100);
+                fprintf(f, "%s\n", buff);
+                free(buff);
+                fclose(f);
+
+                // untested, may need debugging
+                close(0);
+                do_criu();
+                // Weird bug making criu restore crash - this solves it
+                sleep(0.2);
+                system("touch /tmp/after_docriu");
+		create_outputs = getenv_from_file("FITM_CREATE_OUTPUTS");
+		timewarp_mode = getenv_from_file("LETS_DO_THE_TIMEWARP_AGAIN");
+
+                if (timewarp_mode) {
+                    exit(0);
+		}
+                if (!timewarp_mode) {
+                    char* shm_env_var = getenv_from_file(SHM_ENV_VAR);
+                    char* afl_inst_ratio = getenv_from_file("AFL_INST_RATIO");
+                    if(shm_env_var){
+                        afl_setup(shm_env_var, afl_inst_ratio);
+                        afl_forkserver(cpu);
+                    } else {
+                        puts("Forkserver not started, since SHM_ENV_VAR env variable is missing");
+                    }
+                }
+
+                // We want to get input from files so we pipe the file we get from AFL through an environment var into here.
+                // The file is used as stdin
+                char* input = getenv_from_file("INPUT_FILENAME");
+                FILE* input_file = fopen(input, "r");
+                if(!input_file){
+                    printf("fatal: could not fopen INPUT_FILENAME: %s\n", input);
+                    exit(1);
+                }
+                int input_fd = fileno(input_file);
+                if(!input_fd){
+                    printf("fatal: could not: %s\n", input);
+                    perror("fatal: could not fileno INPUT_FILENAME");
+                    exit(1);
+                }
+                dup2(input_fd, arg1);
+                close(input_fd);
+            }
             if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))
                 return -TARGET_EFAULT;
             ret = get_errno(safe_read(arg1, p, arg3));
@@ -6962,8 +6405,16 @@
         }
         return ret;
     case TARGET_NR_write:
+        if ((is_socket >> arg1) & 1){
+            // TODO: Julian, can you checkout how to patch this properly?
+            sent = true;
+        }
         if (arg2 == 0 && arg3 == 0) {
-            return get_errno(safe_write(arg1, 0, 0));
+            if(!create_outputs) {
+                return 0;
+            } else {
+                return get_errno(safe_write(arg1, 0, 0));
+            }
         }
         if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))
             return -TARGET_EFAULT;
@@ -6972,11 +6423,27 @@
             memcpy(copy, p, arg3);
             ret = fd_trans_target_to_host_data(arg1)(copy, arg3);
             if (ret >= 0) {
-                ret = get_errno(safe_write(arg1, copy, ret));
+                if(create_outputs) {
+                    ret = get_errno(safe_write(arg1, copy, ret));
+                }
             }
             g_free(copy);
         } else {
-            ret = get_errno(safe_write(arg1, p, arg3));
+            if(!create_outputs) {
+                _ = system("ls -la /proc/self/fd > /tmp/fitm-arg3");
+                ret = arg3;
+            } else {
+                _ = system("ls -la /proc/self/fd > /tmp/fitm-safewrite2");
+                FILE *fp;
+                char *uuid = get_new_uuid();
+                char path[49] = "/tmp/fitm-";
+                strncat(path, uuid, 37);
+                fp = fopen(path, "w+");
+                fprintf(fp, "arg1: %ld\np: %s\narg3: %ld", arg1, (char *)p, arg3);
+                fclose(fp);
+
+                ret = get_errno(safe_write(arg1, p, arg3));
+            }
         }
         unlock_user(p, arg2, 0);
         return ret;
@@ -7324,10 +6791,12 @@
 #ifdef TARGET_NR_stime /* not on alpha */
     case TARGET_NR_stime:
         {
-            time_t host_time;
-            if (get_user_sal(host_time, arg1))
+            struct timespec ts;
+            ts.tv_nsec = 0;
+            if (get_user_sal(ts.tv_sec, arg1)) {
                 return -TARGET_EFAULT;
-            return get_errno(stime(&host_time));
+            }
+            return get_errno(clock_settime(CLOCK_REALTIME, &ts));
         }
 #endif
 #ifdef TARGET_NR_alarm /* not on alpha */
@@ -8558,7 +8027,7 @@
 #endif
 #ifdef TARGET_NR_socketcall
     case TARGET_NR_socketcall:
-        return do_socketcall(arg1, arg2);
+        return do_socketcall(cpu, arg1, arg2);
 #endif
 #ifdef TARGET_NR_accept
     case TARGET_NR_accept:
@@ -8590,15 +8059,15 @@
 #endif
 #ifdef TARGET_NR_listen
     case TARGET_NR_listen:
-        return get_errno(listen(arg1, arg2));
+        return 0;
 #endif
 #ifdef TARGET_NR_recv
     case TARGET_NR_recv:
-        return do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);
+        return do_recvfrom(cpu, arg1, arg2, arg3, arg4, 0, 0);
 #endif
 #ifdef TARGET_NR_recvfrom
     case TARGET_NR_recvfrom:
-        return do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);
+        return do_recvfrom(cpu, arg1, arg2, arg3, arg4, arg5, arg6);
 #endif
 #ifdef TARGET_NR_recvmsg
     case TARGET_NR_recvmsg:
@@ -8624,6 +8093,7 @@
 #endif
 #ifdef TARGET_NR_shutdown
     case TARGET_NR_shutdown:
+        is_socket &= ~(long long int)(1 << arg1);
         return get_errno(shutdown(arg1, arg2));
 #endif
 #if defined(TARGET_NR_getrandom) && defined(__NR_getrandom)
@@ -9340,6 +8810,7 @@
         return ret;
 #endif
     case TARGET_NR_getsid:
+        getpid();
         return get_errno(getsid(arg1));
 #if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */
     case TARGET_NR_fdatasync:
@@ -9985,7 +9456,7 @@
         return get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));
 #if defined(TARGET_NR_fchownat)
     case TARGET_NR_fchownat:
-        if (!(p = lock_user_string(arg2))) 
+        if (!(p = lock_user_string(arg2)))
             return -TARGET_EFAULT;
         ret = get_errno(fchownat(arg1, p, low2highuid(arg3),
                                  low2highgid(arg4), arg5));
@@ -10529,7 +10000,7 @@
         return TARGET_PAGE_SIZE;
 #endif
     case TARGET_NR_gettid:
-        return get_errno(gettid());
+        return get_errno(sys_gettid());
 #ifdef TARGET_NR_readahead
     case TARGET_NR_readahead:
 #if TARGET_ABI_BITS == 32
@@ -10813,8 +10284,19 @@
         return get_errno(safe_tkill((int)arg1, target_to_host_signal(arg2)));
 
     case TARGET_NR_tgkill:
-        return get_errno(safe_tgkill((int)arg1, (int)arg2,
-                         target_to_host_signal(arg3)));
+        {
+          int pid  = (int)arg1,
+              tgid = (int)arg2,
+              sig  = (int)arg3;
+
+          /* Not entirely sure if the below is correct for all architectures. */
+
+          if(afl_forksrv_pid && afl_forksrv_pid == pid && sig == SIGABRT)
+              pid = tgid = getpid();
+
+          ret = get_errno(safe_tgkill(pid, tgid, target_to_host_signal(sig)));
+
+        }
 
 #ifdef TARGET_NR_set_robust_list
     case TARGET_NR_set_robust_list:
